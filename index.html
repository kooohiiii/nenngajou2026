<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>馬インベーダー</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    /* スマホ用：やりなおすボタン */
    #restartBtn {
      position: fixed;
      left: 50%;
      top: 58%;
      transform: translate(-50%, -50%);
      padding: 14px 18px;
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.7);
      background: rgba(0,0,0,0.75);
      color: #fff;
      display: none;
      z-index: 10;
      -webkit-tap-highlight-color: transparent;
    }
    #restartBtn:active { transform: translate(-50%, -50%) scale(0.98); }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<button id="restartBtn">やりなおす</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const restartBtn = document.getElementById("restartBtn");

  // ===== Utility =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();

  // ===== Resize =====
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener("resize", () => {
    resize();
    // 画面回転などで難易度が急変しないよう、敵配置だけ作り直し（進行は維持）
    reflowFormation();
  }, { passive: true });
  resize();

  // ===== Stage Assets =====
  const stages = [
    { name: "STAGE 1", src: "horse1.png" },
    { name: "STAGE 2", src: "horse2.png" },
    { name: "STAGE 3", src: "phoenix.png" },
  ];

  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ ok: true, img });
      img.onerror = () => resolve({ ok: false, img: null });
      img.src = src;
    });
  }

  // stageImages[i] = {ok, img}
  const stageImages = Array(stages.length).fill(null);

  // 先に読み込み開始（失敗してもフォールバックで動く）
  (async () => {
    for (let i = 0; i < stages.length; i++) {
      stageImages[i] = await loadImage(stages[i].src);
    }
  })();

  // ===== Game State =====
  const state = {
    running: true,
    won: false,
    lost: false,
    score: 0,
    stage: 0, // 0..2
  };

  // ===== Player =====
  const player = {
    w: 44,
    h: 18,
    x: 0,
    y: 0,
    speed: 420,
    cooldownMs: 130,
    lastShotAt: -1e9,
  };

  // ===== Bullets =====
  const bullets = [];
  const enemyBullets = [];
  let bulletSpeed = 720;
  let enemyBulletSpeed = 320;

  // ===== Explosions =====
  const explosions = [];
  function spawnExplosion(x, y, power = 1) {
    const ttl = 0.40;
    const parts = [];
    const n = Math.floor(18 * power);
    for (let i = 0; i < n; i++) {
      const a = (Math.PI * 2) * (i / n) + (Math.random() - 0.5) * 0.25;
      const sp = (80 + Math.random() * 220) * power;
      parts.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: 0,
        ttl: 0.20 + Math.random() * 0.30
      });
    }
    explosions.push({ x, y, life: 0, ttl, parts });
  }

  // ===== Invaders =====
  const invaders = [];
  const inv = {
    cols: 6,
    rows: 4,
    w: 54,
    h: 42,
    gapX: 18,
    gapY: 16,
    offsetX: 0,
    offsetY: 78,
    dir: 1,
    speed: 45,
    drop: 18,
    shootChance: 0.15
  };

  // ===== Input =====
  const keys = { left:false, right:false, shoot:false };

  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = true;
    if (e.code === "Space" || e.code === "KeyZ") keys.shoot = true;
    if (e.code === "Enter") {
      if (!state.running) restartStage();
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = false;
    if (e.code === "Space" || e.code === "KeyZ") keys.shoot = false;
  });

  // ===== Touch (スマホ特化) =====
  let touchMode = false;
  let touchLeft = false, touchRight = false, touchShoot = false;

  function resetTouch() { touchLeft = touchRight = touchShoot = false; }

  function handleTouch(clientX, clientY, isDown) {
    touchMode = true;
    const w = window.innerWidth;
    const h = window.innerHeight;
    const x = clamp(clientX, 0, w);
    const y = clamp(clientY, 0, h);

    resetTouch();
    if (!isDown) return;

    const moveZoneTop = h * 0.72; // 下28% 移動ゾーン
    const inMoveZone = y >= moveZoneTop;

    if (inMoveZone) {
      if (x < w * 0.5) touchLeft = true;
      else touchRight = true;
    } else {
      touchShoot = true;
    }
  }

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    handleTouch(e.clientX, e.clientY, true);
  });
  canvas.addEventListener("pointermove", (e) => {
    handleTouch(e.clientX, e.clientY, e.buttons === 1);
  });
  canvas.addEventListener("pointerup", () => resetTouch());

  // ===== Restart Button =====
  restartBtn.addEventListener("click", () => restartStage());
  // ついでに：終了画面中はキャンバスをタップしてもやり直せる
  canvas.addEventListener("click", () => {
    if (!state.running) restartStage();
  });

  function showRestartButton(show) {
    restartBtn.style.display = show ? "block" : "none";
  }

  // ===== Difficulty scaling (screen-aware) =====
  function applyScreenAwareTuning() {
    const W = window.innerWidth;
    const H = window.innerHeight;
    const minDim = Math.min(W, H);

    // 敵サイズ：画面に合わせて自動
    inv.w = Math.floor(clamp(W * 0.11, 46, 78));
    inv.h = Math.floor(inv.w * 0.78);

    // 間隔もスケール
    inv.gapX = Math.floor(clamp(inv.w * 0.35, 12, 26));
    inv.gapY = Math.floor(clamp(inv.h * 0.35, 10, 24));

    // プレイヤー：少し大きめ＆速度も画面依存
    player.w = Math.floor(clamp(W * 0.13, 44, 66));
    player.h = Math.floor(clamp(player.w * 0.40, 18, 26));
    player.speed = clamp(W * 1.15, 360, 650);

    // 弾：スマホでも気持ちよく
    bulletSpeed = clamp(H * 1.35, 650, 980);
    enemyBulletSpeed = clamp(H * 0.62, 260, 460);

    // 敵移動：小画面は遅く、大画面はそれなりに
    inv.speed = clamp(W * 0.12, 32, 70);

    // 落下量：敵高さに比例
    inv.drop = Math.floor(clamp(inv.h * 0.55, 14, 28));

    // 射撃頻度：スマホで地獄にならないよう控えめに
    inv.shootChance = clamp(0.10 + (minDim / 900) * 0.07, 0.10, 0.18);

    // クールダウン：スマホ寄りに
    player.cooldownMs = touchMode ? 120 : 130;
  }

  // ===== Init / Spawn =====
  function resetPlayer() {
    player.x = (window.innerWidth - player.w) / 2;
    player.y = window.innerHeight - player.h - 54;
    player.lastShotAt = -1e9;
  }

  function spawnFormation() {
    invaders.length = 0;
    inv.dir = 1;

    const totalWidth = inv.cols * inv.w + (inv.cols - 1) * inv.gapX;
    inv.offsetX = (window.innerWidth - totalWidth) / 2;
    inv.offsetY = Math.floor(clamp(window.innerHeight * 0.14, 70, 120));

    for (let r = 0; r < inv.rows; r++) {
      for (let c = 0; c < inv.cols; c++) {
        invaders.push({
          x: inv.offsetX + c * (inv.w + inv.gapX),
          y: inv.offsetY + r * (inv.h + inv.gapY),
          w: inv.w,
          h: inv.h,
          alive: true
        });
      }
    }
  }

  function reflowFormation() {
    // 生存してる敵だけ、現在のサイズ設定で再配置
    applyScreenAwareTuning();
    const alive = invaders.filter(v => v.alive);
    if (alive.length === 0) return;

    // いったん左上から詰め直す（列・行は維持）
    const totalWidth = inv.cols * inv.w + (inv.cols - 1) * inv.gapX;
    inv.offsetX = (window.innerWidth - totalWidth) / 2;
    inv.offsetY = Math.floor(clamp(window.innerHeight * 0.14, 70, 120));

    let idx = 0;
    for (let r = 0; r < inv.rows; r++) {
      for (let c = 0; c < inv.cols; c++) {
        const v = invaders[idx++];
        if (!v) continue;
        v.w = inv.w; v.h = inv.h;
        v.x = inv.offsetX + c * (inv.w + inv.gapX);
        v.y = inv.offsetY + r * (inv.h + inv.gapY);
      }
    }
  }

  function restartStage() {
    applyScreenAwareTuning();
    state.running = true;
    state.won = false;
    state.lost = false;
    bullets.length = 0;
    enemyBullets.length = 0;
    explosions.length = 0;
    showRestartButton(false);
    resetPlayer();
    spawnFormation();
  }

  function nextStage() {
    state.stage = Math.min(state.stage + 1, stages.length - 1);
    restartStage();
  }

  // 初期開始
  applyScreenAwareTuning();
  restartStage();

  // ===== Gameplay =====
  function shootPlayer(tms) {
    if (tms - player.lastShotAt < player.cooldownMs) return;
    player.lastShotAt = tms;
    bullets.push({
      x: player.x + player.w / 2 - 2,
      y: player.y - 10,
      w: 4, h: 10,
      vy: -bulletSpeed
    });
  }

  function shootEnemy(from) {
    enemyBullets.push({
      x: from.x + from.w / 2 - 2,
      y: from.y + from.h + 2,
      w: 4, h: 10,
      vy: enemyBulletSpeed
    });
  }

  function aabb(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  let last = now();

  function step() {
    const t = now();
    const dt = Math.min(0.033, (t - last) / 1000);
    last = t;

    if (state.running) update(dt, t);
    draw();

    requestAnimationFrame(step);
  }

  function update(dt, tms) {
    applyScreenAwareTuning(); // 画面サイズやtouchMode変化に追従

    const left  = keys.left  || touchLeft;
    const right = keys.right || touchRight;
    const shoot = keys.shoot || touchShoot;

    // Player move
    let vx = 0;
    if (left) vx -= player.speed;
    if (right) vx += player.speed;
    player.x = clamp(player.x + vx * dt, 10, window.innerWidth - player.w - 10);

    if (shoot) shootPlayer(tms);

    // Bullets move
    for (const b of bullets) b.y += b.vy * dt;
    for (const b of enemyBullets) b.y += b.vy * dt;

    for (let i = bullets.length - 1; i >= 0; i--) {
      if (bullets[i].y + bullets[i].h < -30) bullets.splice(i, 1);
    }
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      if (enemyBullets[i].y > window.innerHeight + 50) enemyBullets.splice(i, 1);
    }

    // Explosions update
    for (let i = explosions.length - 1; i >= 0; i--) {
      const ex = explosions[i];
      ex.life += dt;
      for (const p of ex.parts) {
        p.life += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= (1 - 2.8 * dt);
        p.vy *= (1 - 2.8 * dt);
      }
      if (ex.life >= ex.ttl) explosions.splice(i, 1);
    }

    // Invaders alive check
    const aliveInv = invaders.filter(v => v.alive);
    if (aliveInv.length === 0) {
      // ステージクリア
      state.score += 100;
      state.running = false;
      state.won = true;
      showRestartButton(true);
      // 自動で次へ行きたいならここで nextStage() でもOK
      return;
    }

    // Group bounds
    let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const v of aliveInv) {
      minX = Math.min(minX, v.x);
      maxX = Math.max(maxX, v.x + v.w);
      maxY = Math.max(maxY, v.y + v.h);
    }

    // Stage difficulty (控えめに上げる)
    const remainRatio = aliveInv.length / (inv.cols * inv.rows);
    const stageBoost = 1 + state.stage * 0.18; // 1.00, 1.18, 1.36
    const thinBoost  = 1 + (1 - remainRatio) * 0.85; // 残り少ないと少し速い
    const vxInv = inv.speed * stageBoost * thinBoost * inv.dir;

    const nextMinX = minX + vxInv * dt;
    const nextMaxX = maxX + vxInv * dt;

    const hitLeft  = nextMinX < 10;
    const hitRight = nextMaxX > window.innerWidth - 10;

    if (hitLeft || hitRight) {
      inv.dir *= -1;
      for (const v of aliveInv) v.y += inv.drop;
    } else {
      for (const v of aliveInv) v.x += vxInv * dt;
    }

    // Lose: invaders reach player line
    if (maxY >= player.y - 10) {
      state.running = false;
      state.lost = true;
      state.won = false;
      showRestartButton(true);
      spawnExplosion(player.x + player.w/2, player.y + player.h/2, 1.3);
      return;
    }

    // Enemy shooting: bottom-most per column
    const shootPerSec = inv.shootChance * stageBoost * (1 + (1 - remainRatio) * 0.6);
    if (Math.random() < shootPerSec * dt) {
      const col = Math.floor(Math.random() * inv.cols);
      let shooter = null;
      for (let r = inv.rows - 1; r >= 0; r--) {
        const idx = r * inv.cols + col;
        const v = invaders[idx];
        if (v && v.alive) { shooter = v; break; }
      }
      if (shooter) shootEnemy(shooter);
    }

    // Collisions: player bullets vs invaders
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
      const b = bullets[bi];
      let hit = null;

      for (const v of invaders) {
        if (!v.alive) continue;
        if (aabb(b, v)) { hit = v; break; }
      }

      if (hit) {
        hit.alive = false;
        bullets.splice(bi, 1);
        state.score += 10;
        spawnExplosion(hit.x + hit.w/2, hit.y + hit.h/2, 1);
      }
    }

    // Collisions: enemy bullets vs player
    for (let bi = enemyBullets.length - 1; bi >= 0; bi--) {
      const b = enemyBullets[bi];
      if (aabb(b, player)) {
        state.running = false;
        state.lost = true;
        state.won = false;
        showRestartButton(true);
        spawnExplosion(player.x + player.w/2, player.y + player.h/2, 1.3);
        break;
      }
    }

    // タップ発射は瞬間入力扱い（長押し連射したいならここ消す）
    touchShoot = false;
  }

  // ===== Draw =====
  function drawExplosion(ex) {
    const t = ex.life / ex.ttl;
    ctx.globalAlpha = 0.35 * (1 - t);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, 10 + t * 30, 0, Math.PI * 2);
    ctx.stroke();

    for (const p of ex.parts) {
      const pt = p.life / p.ttl;
      if (pt >= 1) continue;
      ctx.globalAlpha = 0.9 * (1 - pt);
      ctx.fillStyle = "#fff";
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
  }

  function drawInvaderFallback(v) {
    ctx.strokeStyle = "#fff";
    ctx.strokeRect(v.x, v.y, v.w, v.h);
    ctx.fillStyle = "#fff";
    ctx.fillRect(v.x + 6, v.y + 6, 4, 4);
    ctx.fillRect(v.x + v.w - 10, v.y + 6, 4, 4);
    ctx.fillRect(v.x + 10, v.y + v.h - 6, v.w - 20, 3);
  }

  function getStageImage() {
    const rec = stageImages[state.stage];
    return rec && rec.ok ? rec.img : null;
  }

  function draw() {
    const W = window.innerWidth;
    const H = window.innerHeight;

    ctx.clearRect(0, 0, W, H);

    // BG
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    // Stars
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#fff";
    for (let i = 0; i < 46; i++) {
      const x = (i * 97) % W;
      const y = (i * 173) % H;
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;

    // HUD
    ctx.fillStyle = "#fff";
    ctx.font = "16px sans-serif";
    ctx.fillText(`SCORE ${state.score}`, 12, 24);
    ctx.fillText(`${stages[state.stage].name}`, 12, 44);

    ctx.globalAlpha = 0.75;
    ctx.font = "12px sans-serif";
    if (touchMode) ctx.fillText(`下の左右：移動 / 上をタップ：発射`, 12, H - 12);
    else ctx.fillText(`←→/A D 移動  SPACE/Z 発射  ENTER リスタート`, 12, H - 12);
    ctx.globalAlpha = 1;

    // Player
    ctx.fillStyle = "#fff";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x + player.w/2 - 6, player.y - 7, 12, 7);

    // Bullets
    ctx.fillStyle = "#fff";
    for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.globalAlpha = 0.9;
    for (const b of enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.globalAlpha = 1;

    // Invaders
    const img = getStageImage();
    for (const v of invaders) {
      if (!v.alive) continue;
      if (img) ctx.drawImage(img, v.x, v.y, v.w, v.h);
      else drawInvaderFallback(v);
    }

    // Explosions
    for (const ex of explosions) drawExplosion(ex);

    // Touch zones overlay
    if (touchMode && state.running) {
      ctx.globalAlpha = 0.16;
      ctx.strokeStyle = "#fff";
      ctx.beginPath();
      ctx.moveTo(W/2, H*0.72); ctx.lineTo(W/2, H);
      ctx.moveTo(0, H*0.72); ctx.lineTo(W, H*0.72);
      ctx.stroke();

      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#fff";
      ctx.font = "18px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("◀︎", W*0.25, H*0.87);
      ctx.fillText("▶︎", W*0.75, H*0.87);
      ctx.textAlign = "left";
      ctx.globalAlpha = 1;
    }

    // End screen overlay
    if (!state.running) {
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "28px sans-serif";
      const msg = state.won ? "CLEAR!" : "GAME OVER";
      ctx.fillText(msg, W/2, H/2 - 38);

      ctx.font = "16px sans-serif";
      if (state.won) {
        const nextMsg = (state.stage < stages.length - 1) ? "つぎのステージへ" : "もう一回やる？";
        ctx.fillText(nextMsg, W/2, H/2 - 8);
        // クリア時はボタンで次ステージにする（わかりやすい）
        restartBtn.textContent = (state.stage < stages.length - 1) ? "つぎへ" : "もう一回";
      } else {
        restartBtn.textContent = "やりなおす";
      }
      ctx.textAlign = "left";
    }
  }

  // クリア時のボタン挙動：次ステージ / もう一回
  restartBtn.addEventListener("click", () => {
    if (state.won) {
      if (state.stage < stages.length - 1) {
        state.stage++;
        state.running = true;
        state.won = false;
        showRestartButton(false);
        bullets.length = 0;
        enemyBullets.length = 0;
        explosions.length = 0;
        resetPlayer();
        spawnFormation();
      } else {
        // 最終面クリア後は同ステージで再スタート
        restartStage();
      }
    } else {
      restartStage();
    }
  }, { passive: true });

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
