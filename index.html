<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>馬インベーダー</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    .btn{
      position: fixed;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 18px;
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.80);
      background: rgba(0,0,0,0.78);
      color: #fff;
      display: none;
      z-index: 10;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      cursor: pointer;
    }
    .btn:active { transform: translate(-50%, -50%) scale(0.98); }
    #primaryBtn { top: 62%; }
    #secondaryBtn { top: 72%; font-size: 14px; opacity: 0.92; }

    .btn-small{
      font-size: 13px !important;
      padding: 10px 14px !important;
      opacity: 0.85 !important;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<button id="primaryBtn" class="btn">　</button>
<button id="secondaryBtn" class="btn">　</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const primaryBtn = document.getElementById("primaryBtn");
  const secondaryBtn = document.getElementById("secondaryBtn");

  // ===== Utils =====
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const rand = (a,b) => a + Math.random()*(b-a);

  // ===== Resize =====
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", () => {
    resize();
    applyScreenAwareTuning();
    reflowForStage();
  }, { passive: true });
  resize();

  // ===== Assets =====
  const stages = [
    { name: "STAGE 1", src: "horse1.png" },
    { name: "STAGE 2", src: "horse2.png" },
    { name: "BOSS",    src: "phoenix.png" },
    { name: "SECRET",  src: "secret.png" }, // optional
  ];

  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ ok:true, img });
      img.onerror = () => resolve({ ok:false, img:null });
      img.src = src;
    });
  }

  const stageImages = Array(stages.length).fill(null);
  (async () => {
    for (let i = 0; i < stages.length; i++) stageImages[i] = await loadImage(stages[i].src);
  })();

  function getImgForStage(stageIndex) {
    if (stageIndex === 3) {
      const rec = stageImages[3];
      if (rec && rec.ok) return rec.img;
      const alt = stageImages[2];
      return (alt && alt.ok) ? alt.img : null;
    }
    const rec = stageImages[stageIndex];
    return (rec && rec.ok) ? rec.img : null;
  }

  // ===== State =====
  // tutorial / play / stage3clear / secretWarn / end
  const state = {
    screen: "tutorial",
    running: false,
    stage: 0,      // 0,1,2,3(secret)
    endKind: "",   // "lose" | "win" | "secretWin" | "secretLose"
    time: 0,
  };

  // ===== Player =====
  const player = {
    w: 52, h: 20,
    x: 0, y: 0,
    speed: 500,
    cooldownMs: 260,     // ★発射頻度 半分（元130→260）
    lastShotAt: -1e9,
  };

  // ===== Bullets =====
  const bullets = [];
  const enemyBullets = [];
  let bulletSpeed = 760;
  let enemyBulletSpeed = 320;

  // ===== Effects =====
  const explosions = [];
  const confetti = [];

  function spawnExplosion(x,y,power=1) {
    const ttl = 0.42;
    const parts = [];
    const n = Math.floor(20 * power);
    for (let i=0;i<n;i++){
      const a = (Math.PI*2)*(i/n) + (Math.random()-0.5)*0.25;
      const sp = (90 + Math.random()*240) * power;
      parts.push({ x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:0, ttl:0.20+Math.random()*0.35 });
    }
    explosions.push({ x,y, life:0, ttl, parts });
  }

  function spawnConfettiBurst() {
    const W = window.innerWidth, H = window.innerHeight;
    for (let i=0;i<140;i++){
      confetti.push({
        x: W/2 + rand(-80,80),
        y: H*0.35 + rand(-60,60),
        vx: rand(-260,260),
        vy: rand(-320,80),
        life: 0,
        ttl: rand(1.0, 1.8),
        w: rand(2,5),
        h: rand(6,12),
      });
    }
  }

  // ===== Enemies =====
  const enemies = [];
  const inv = {
    cols: 6, rows: 4,
    w: 64, h: 48,
    gapX: 18, gapY: 16,
    offsetX: 0, offsetY: 92,
    dir: 1,
    speed: 52,
  };

  // ===== Boss/Secret =====
  let bossPhaseTime = 0;
  const bossNormal = { count:2, hp:30, shootMult:2.40 };

  const secret = {
    phase: 1,
    lastPhase: 1,
    main: null,
    minions: [],
    messageTimer: 0, // ※表示はしない（中身だけ残す）
    invulnTimer: 0,
  };

  // ===== Input =====
  const keys = { left:false, right:false };

  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = true;

    if (e.code === "Enter") {
      if (state.screen === "tutorial") startGame();
      else if (state.screen === "secretWarn") startSecret();
      else if (state.screen === "end") {
        if (state.endKind === "secretLose") restartSecretFromCheckpoint();
        else handleEndPrimary();
      }
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = false;
  });

  let touchMode=false, touchLeft=false, touchRight=false;
  function resetTouch(){ touchLeft=touchRight=false; }

  function handleTouch(clientX, clientY, isDown) {
    touchMode=true;
    const W=window.innerWidth, H=window.innerHeight;
    const x=clamp(clientX,0,W), y=clamp(clientY,0,H);
    resetTouch();
    if(!isDown) return;
    const moveZoneTop = H*0.72;
    if(y >= moveZoneTop){
      if(x < W*0.5) touchLeft=true;
      else touchRight=true;
    }
  }

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);

    if (state.screen === "tutorial") { startGame(); return; }

    // ★余韻タイム：キャンバス無反応（ボタンだけ）
    if (state.screen === "stage3clear") return;

    if (state.screen === "secretWarn") { startSecret(); return; }

    // endも誤タップ無効（ボタンだけ）
    if (state.screen === "end") return;

    if (!state.running) return;
    handleTouch(e.clientX, e.clientY, true);
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!state.running) return;
    handleTouch(e.clientX, e.clientY, e.buttons === 1);
  });
  canvas.addEventListener("pointerup", () => resetTouch());

  // ===== Buttons =====
  function hideButtons(){
    primaryBtn.style.display = "none";
    secondaryBtn.style.display = "none";
    primaryBtn.onclick = null;
    secondaryBtn.onclick = null;
    secondaryBtn.classList.remove("btn-small");
  }
  function showPrimary(text, onClick){
    primaryBtn.textContent = text;
    primaryBtn.style.display = "block";
    primaryBtn.onclick = onClick;
  }
  function showSecondary(text, onClick){
    secondaryBtn.textContent = text;
    secondaryBtn.style.display = "block";
    secondaryBtn.onclick = onClick;
  }

  // ===== Tuning =====
  let baseShootChance = 0.14;

  function applyScreenAwareTuning() {
    const W=window.innerWidth, H=window.innerHeight;
    const minDim = Math.min(W,H);

    // ★列数調整
    // Stage1: 左右両端2列減（6→2）
    // Stage2: 1列減（4→3）
    if (state.stage === 0) { inv.cols = 2; inv.rows = 4; }
    else if (state.stage === 1) { inv.cols = 3; inv.rows = 3; }
    else { inv.cols = 6; inv.rows = 4; } // ステージ3以降は通常計算を使う（実際はボスなので formationは使わない）

    // 敵サイズ（少数になったので少し大きめ寄り）
    const enemyScale =
      (state.stage === 0) ? 0.24 :
      (state.stage === 1) ? 0.20 :
      0.13;

    inv.w = Math.floor(clamp(W*enemyScale, 60, 140));
    inv.h = Math.floor(inv.w*0.78);
    inv.gapX = Math.floor(clamp(inv.w*0.32, 14, 32));
    inv.gapY = Math.floor(clamp(inv.h*0.30, 10, 28));
    inv.speed = clamp(W*0.10, 30, 78);

    player.w = Math.floor(clamp(W*0.15, 48, 74));
    player.h = Math.floor(clamp(player.w*0.40, 18, 28));
    player.speed = clamp(W*1.15, 360, 760);

    bulletSpeed = clamp(H*1.18, 620, 920);
    enemyBulletSpeed = clamp(H*0.60, 260, 520);

    baseShootChance = clamp(0.10 + (minDim/900)*0.08, 0.10, 0.20);

    // ★発射頻度 半分（元: touch 120 / key 130）
    player.cooldownMs = touchMode ? 240 : 260;
  }

  // ===== Spawns =====
  function resetPlayer(){
    player.x = (window.innerWidth - player.w)/2;
    // ★自機を「1つ分」上へ（player.h ぶん上げる）
    player.y = window.innerHeight - player.h - 54 - player.h;
    player.lastShotAt = -1e9;
  }

  function spawnFormation(){
    enemies.length=0;
    inv.dir=1;

    const totalW = inv.cols*inv.w + (inv.cols-1)*inv.gapX;
    inv.offsetX = (window.innerWidth - totalW)/2;
    inv.offsetY = Math.floor(clamp(window.innerHeight*0.14, 70, 130));

    const isStage2 = (state.stage===1);

    for(let r=0;r<inv.rows;r++){
      for(let c=0;c<inv.cols;c++){
        const hp = (isStage2 && (r===0 || r===inv.rows-1)) ? 2 : 1;
        enemies.push({
          x: inv.offsetX + c*(inv.w+inv.gapX),
          y: inv.offsetY + r*(inv.h+inv.gapY),
          w: inv.w, h: inv.h,
          alive:true,
          hp, maxHp:hp,
          isBoss:false,
          row:r, col:c
        });
      }
    }
  }

  function spawnBossNormal(){
    enemies.length=0;
    inv.dir=1;
    bossPhaseTime=0;

    const W=window.innerWidth, H=window.innerHeight;
    const bw = Math.floor(clamp(W*0.20, 90, 160));
    const bh = Math.floor(bw*0.78);
    const y = Math.floor(clamp(H*0.18, 90, 170));
    const x1 = Math.floor(W*0.33 - bw/2);
    const x2 = Math.floor(W*0.67 - bw/2);

    for(let i=0;i<bossNormal.count;i++){
      enemies.push({
        x: i===0?x1:x2,
        y,
        w:bw, h:bh,
        alive:true,
        hp: bossNormal.hp,
        maxHp: bossNormal.hp,
        isBoss:true,
        row:0, col:i
      });
    }
  }

  // ===== Secret: HP always MAX on restart =====
  function startSecretAtPhase(phase){
    state.stage = 3;
    state.screen = "play";
    state.running = true;
    hideButtons();
    resetTouch();
    applyScreenAwareTuning();
    resetPlayer();

    bullets.length = 0;
    enemyBullets.length = 0;
    explosions.length = 0;

    secret.minions = [];
    secret.main = null;
    secret.messageTimer = 0;
    secret.invulnTimer = 0;

    const W=window.innerWidth, H=window.innerHeight;

    if (phase === 1){
      secret.phase = 1;
      const bw = Math.floor(clamp(W*0.26, 120, 240));
      const bh = Math.floor(bw*0.78);

      secret.main = {
        x: Math.floor(W*0.5 - bw/2),
        y: Math.floor(clamp(H*0.18, 90, 170)),
        w:bw, h:bh,
        alive:true,
        hp: 80, maxHp: 80,
        invuln: true
      };

      for(let i=0;i<3;i++){
        const mw = Math.floor(clamp(W*0.16, 90, 160));
        const mh = Math.floor(mw*0.78);
        secret.minions.push({
          x: Math.floor(W*0.18 + i*(W*0.24)),
          y: Math.floor(clamp(H*0.38, 220, 320)),
          w: mw, h: mh,
          alive:true,
          hp: 18, maxHp: 18,
          vx: rand(-220,220),
          vy: rand(-170,170),
          role: (i === 0 ? "homing" : (i === 1 ? "wavy" : "normal")),
        });
      }
      return;
    }

    if (phase === 2){
      secret.phase = 2;
      secret.messageTimer = 0.70; // 表示はしない
      secret.invulnTimer = 0.95;

      const bw = Math.floor(clamp(W*0.26, 120, 240));
      const bh = Math.floor(bw*0.78);

      secret.main = {
        x: Math.floor(W*0.5 - bw/2),
        y: Math.floor(clamp(H*0.18, 90, 170)),
        w:bw, h:bh,
        alive:true,
        hp: 80, maxHp: 80,
        invuln: false
      };
      inv.dir = 1;
      bossPhaseTime = 0;
      return;
    }

    // phase 3
    secret.phase = 3;
    secret.messageTimer = 0.90; // 表示はしない
    secret.invulnTimer = 1.05;

    const nw = Math.floor(clamp(W*0.14, 70, 120));
    const nh = Math.floor(nw*0.78);

    const deg = rand(30, 45) * Math.PI / 180;
    const speed = rand(680, 860);
    const sx = Math.random() < 0.5 ? -1 : 1;
    const sy = Math.random() < 0.5 ? -1 : 1;
    const vx0 = Math.cos(deg) * speed * sx;
    const vy0 = Math.sin(deg) * speed * sy;

    secret.main = {
      x: Math.floor(W*0.5 - nw/2),
      y: Math.floor(clamp(H*0.22, 110, 190)),
      w:nw, h:nh,
      alive:true,
      hp: 28, maxHp: 28,
      invuln: false,
      vx: vx0,
      vy: vy0,
    };
    inv.dir = 1;
    bossPhaseTime = 0;
  }

  // ===== Game flow =====
  function restartPlayStage(){
    applyScreenAwareTuning();
    state.running = true;
    hideButtons();
    resetTouch();
    resetPlayer();
    bullets.length = 0;
    enemyBullets.length = 0;
    explosions.length = 0;
    confetti.length = 0;

    if (state.stage === 0 || state.stage === 1) spawnFormation();
    else if (state.stage === 2) spawnBossNormal();
  }

  function startGame(){
    state.screen = "play";
    state.stage = 0;
    state.running = true;
    hideButtons();
    restartPlayStage();
  }

  function goSecretWarn(){
    state.screen = "secretWarn";
    state.running = false;
    hideButtons();
    showPrimary("裏ボス開始", startSecret);
    showSecondary("やめとく", () => {
      state.screen="end";
      state.endKind="win";
      hideButtons();
      showPrimary("もう一回", handleEndPrimary);
    });
  }

  function startSecret(){ startSecretAtPhase(1); }
  function restartSecretFromCheckpoint(){ startSecretAtPhase(secret.lastPhase); }
  function restartSecretFromStart(){ startSecretAtPhase(1); }

  function handleEndPrimary(){
    if (state.endKind === "lose") {
      state.screen = "play";
      state.running = true;
      restartPlayStage();
      return;
    }
    if (state.endKind === "win" || state.endKind === "secretWin") {
      state.stage = 0;
      state.screen = "play";
      state.running = true;
      restartPlayStage();
      return;
    }
  }

  function reflowForStage(){
    if (state.screen !== "play") return;
    resetPlayer();
  }

  // ===== Shooting =====
  function shootPlayer(tms){
    if (tms - player.lastShotAt < player.cooldownMs) return;
    player.lastShotAt = tms;
    bullets.push({ x: player.x + player.w/2 - 2, y: player.y - 10, w: 4, h: 10, vx: 0, vy: -bulletSpeed });
  }

  function shootEnemy(from, opt = {}){
    enemyBullets.push({
      x: from.x + from.w/2 - 2,
      y: from.y + from.h + 2,
      w: 4, h: 10,
      vx: opt.vx || 0,
      vy: opt.vy || enemyBulletSpeed,
      type: opt.type || "normal",
      color: opt.color || "#fff",
      age: 0,
      splitAt: opt.splitAt ?? 0.28,
      splitDone: false,
      pattern: opt.pattern || null,
      amp: opt.amp || 0,
      freq: opt.freq || 0,
      homing: opt.homing || 0,
    });
  }

  function shootEnemyDouble(from){
    shootEnemy(from, { type:"normal", color:"#fff" });
    shootEnemy(from, { type:"delayed", color:"#fff" });
    enemyBullets[enemyBullets.length-1].age = -0.12;
    enemyBullets[enemyBullets.length-1].splitDone = true;
  }

  function shootBossSplit(from, pattern, extraVx=0, vy=null){
    shootEnemy(from, { type:"split", splitAt:0.24, vx:extraVx, pattern, color:"#fff", vy: (vy ?? enemyBulletSpeed) });
  }

  // ===== Collision =====
  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // ===== Update/Draw loop =====
  let last = now();

  function step(){
    const t=now();
    const dt=Math.min(0.033, (t-last)/1000);
    last=t;
    state.time += dt;

    if (state.screen === "play" && state.running) update(dt, t);
    draw();
    requestAnimationFrame(step);
  }

  function update(dt, tms){
    applyScreenAwareTuning();

    // ★自機は常時オート射撃（発射頻度はcooldownで抑制）
    shootPlayer(tms);

    const left  = keys.left  || touchLeft;
    const right = keys.right || touchRight;

    let vx=0;
    if(left) vx -= player.speed;
    if(right) vx += player.speed;
    player.x = clamp(player.x + vx*dt, 10, window.innerWidth - player.w - 10);

    for (const b of bullets){
      b.x += (b.vx||0)*dt;
      b.y += b.vy*dt;
    }

    for (let i=enemyBullets.length-1;i>=0;i--){
      const b = enemyBullets[i];
      b.age += dt;

      if (b.type === "delayed") {
        if (b.age < 0) continue;
        b.type = "normal";
      }

      if (b.type === "wavy") {
        const swayV = Math.sin(b.age * b.freq) * b.amp;
        b.x += ((b.vx||0) + swayV) * dt;
      } else if (b.type === "homing") {
        const px = player.x + player.w/2;
        const bx = b.x + b.w/2;
        const dx = clamp(px - bx, -320, 320);
        b.vx += (dx * b.homing) * dt;
        b.vx = clamp(b.vx, -320, 320);
        b.x += b.vx * dt;
      } else {
        b.x += (b.vx||0)*dt;
      }
      b.y += b.vy*dt;

      if (b.type === "split" && !b.splitDone && b.age >= b.splitAt) {
        b.splitDone = true;
        const pattern = b.pattern || 1;
        const base = clamp(window.innerWidth * 0.22, 170, 360);
        const slow = base * 0.55;

        const spawnChild = (vxChild) => shootEnemy({x:b.x, y:b.y, w:0,h:0}, { vx:vxChild, vy:b.vy, type:"normal", color:"#fff" });
        if (pattern === 1) { spawnChild(-base); spawnChild(+base); }
        else if (pattern === 2) { spawnChild(-slow); spawnChild(-base); spawnChild(+slow); spawnChild(+base); }
        else { spawnChild(-base); spawnChild(0); spawnChild(+base); }

        enemyBullets.splice(i,1);
        continue;
      }

      if (b.y > window.innerHeight + 120 || b.x < -140 || b.x > window.innerWidth + 140) enemyBullets.splice(i,1);
    }

    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if (b.y + b.h < -90) bullets.splice(i,1);
    }

    for (let i=explosions.length-1;i>=0;i--){
      const ex=explosions[i];
      ex.life += dt;
      for (const p of ex.parts){
        p.life += dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= (1 - 2.8*dt);
        p.vy *= (1 - 2.8*dt);
      }
      if (ex.life >= ex.ttl) explosions.splice(i,1);
    }
    for (let i=confetti.length-1;i>=0;i--){
      const c=confetti[i];
      c.life += dt;
      c.x += c.vx*dt;
      c.y += c.vy*dt;
      c.vy += 420*dt;
      c.vx *= (1 - 0.8*dt);
      if (c.life >= c.ttl) confetti.splice(i,1);
    }

    if (state.stage === 0 || state.stage === 1) updateStage12(dt);
    else if (state.stage === 2) updateBossNormal(dt);
    else updateSecretBoss(dt);
  }

  // ===== End states =====
  function endLose(){
    if (state.stage === 3){
      secret.lastPhase = secret.phase;
      state.endKind = "secretLose";
    } else {
      state.endKind = "lose";
    }
    state.running = false;
    state.screen = "end";
    hideButtons();

    if (state.endKind === "secretLose"){
      showPrimary("この形態からやり直す", restartSecretFromCheckpoint);
      secondaryBtn.classList.add("btn-small");
      showSecondary("第1形態からやり直す", restartSecretFromStart);
    } else {
      showPrimary("やりなおす", handleEndPrimary);
    }
  }

  function endWinNormal(){
    state.running = false;
    state.screen = "end";
    state.endKind = "win";
    hideButtons();
    showPrimary("もう一回", handleEndPrimary);
  }

  function endSecretWin(){
    state.running = false;
    state.screen = "end";
    state.endKind = "secretWin";
    hideButtons();
    showPrimary("もう一回", handleEndPrimary);
  }

  // ===== Stage 1-2 =====
  function updateFormationMovement(dt, aliveInv){
    const isStage2 = (state.stage === 1);

    if (!isStage2) {
      let minX=Infinity, maxX=-Infinity;
      for (const e of aliveInv){ minX=Math.min(minX,e.x); maxX=Math.max(maxX,e.x+e.w); }
      const remainRatio = aliveInv.length / (inv.cols*inv.rows);
      const thinBoost = 1 + (1 - remainRatio)*0.9;
      const vx = inv.speed * thinBoost * inv.dir;

      const nextMin = minX + vx*dt;
      const nextMax = maxX + vx*dt;

      if (nextMin < 10 || nextMax > window.innerWidth - 10) inv.dir *= -1;
      else for (const e of aliveInv) e.x += vx*dt;
      return;
    }

    // stage2 only top row moves
    const movers = aliveInv.filter(e => e.row === 0);
    if (movers.length === 0) return;

    let minX=Infinity, maxX=-Infinity;
    for (const e of movers){ minX=Math.min(minX,e.x); maxX=Math.max(maxX,e.x+e.w); }
    const remainRatio = aliveInv.length / (inv.cols*inv.rows);
    const thinBoost = 1 + (1 - remainRatio)*0.9;
    const vx = inv.speed * 1.55 * thinBoost * inv.dir;

    const nextMin = minX + vx*dt;
    const nextMax = maxX + vx*dt;

    if (nextMin < 10 || nextMax > window.innerWidth - 10) inv.dir *= -1;
    else for (const e of movers) e.x += vx*dt;
  }

  function updateFormationShooting(dt, aliveInv){
    const total = inv.cols*inv.rows;
    const remainRatio = aliveInv.length / total;
    const intensity = 1 + (1 - remainRatio)*0.7;
    const shootPerSec = (state.stage === 0 ? baseShootChance*1.90 : baseShootChance*1.15) * intensity;

    if (Math.random() < shootPerSec * dt){
      const col = Math.floor(Math.random()*inv.cols);
      let shooter=null;
      for(let r=inv.rows-1;r>=0;r--){
        const cand = enemies.find(e => e.alive && !e.isBoss && e.col===col && e.row===r);
        if (cand){ shooter=cand; break; }
      }
      if (shooter){
        if (state.stage===0) shootEnemy(shooter);
        else shootEnemyDouble(shooter);
      }
    }
  }

  function updateStage12(dt){
    const alive = enemies.filter(e => e.alive);
    if (alive.length === 0){
      state.running = false;
      state.screen = "end";
      state.endKind = "win";
      hideButtons();
      showPrimary("つぎへ", () => {
        if (state.stage === 0) state.stage = 1;
        else state.stage = 2;
        state.screen = "play";
        restartPlayStage();
      });
      return;
    }

    updateFormationMovement(dt, alive);
    updateFormationShooting(dt, alive);

    for (let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      let hit=null;
      for (const e of enemies){ if(e.alive && aabb(b,e)){ hit=e; break; } }
      if (hit){
        bullets.splice(bi,1);
        hit.hp -= 1;
        spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 0.8);
        if (hit.hp<=0){ hit.alive=false; spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.1); }
      }
    }

    for (let bi=enemyBullets.length-1; bi>=0; bi--){
      const b=enemyBullets[bi];
      if (aabb(b,player)){
        enemyBullets.splice(bi,1);
        spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
        endLose();
        break;
      }
    }
  }

  // ===== Stage 3 (boss) =====
  function updateBossNormal(dt){
    const aliveBosses = enemies.filter(e => e.alive && e.isBoss);
    if (aliveBosses.length === 0){
      state.running = false;
      state.screen = "stage3clear";
      hideButtons();
      showPrimary("裏ボスへGO", goSecretWarn);
      showSecondary("周回する", () => { state.screen="end"; endWinNormal(); });
      spawnConfettiBurst();
      return;
    }

    bossPhaseTime += dt;

    let minX=Infinity, maxX=-Infinity;
    for (const b of aliveBosses){ minX=Math.min(minX,b.x); maxX=Math.max(maxX,b.x+b.w); }

    const hpSum = aliveBosses.reduce((s,b)=>s+b.hp,0);
    const maxSum = aliveBosses.reduce((s,b)=>s+b.maxHp,0);
    const hpRatio = maxSum>0 ? (hpSum/maxSum) : 0;

    const anger = 1 + (1 - hpRatio)*0.9;
    const vxBoss = inv.speed * 0.95 * anger * inv.dir;

    const nextMin = minX + vxBoss*dt;
    const nextMax = maxX + vxBoss*dt;

    if (nextMin<10 || nextMax>window.innerWidth-10) inv.dir *= -1;
    else for (const b of aliveBosses) b.x += vxBoss*dt;

    for (let i=0;i<aliveBosses.length;i++){
      const b=aliveBosses[i];
      b.y += Math.sin(bossPhaseTime*1.5 + i*2.2) * 6 * dt;
    }

    const shootPerSec = baseShootChance * bossNormal.shootMult * (1 + (1-hpRatio)*1.10);
    if (Math.random() < shootPerSec*dt){
      const b = aliveBosses[Math.floor(Math.random()*aliveBosses.length)];
      let pattern=1;
      if (hpRatio>=0.666) pattern=1;
      else if (hpRatio>=0.333) pattern=(Math.random()<0.5)?1:2;
      else pattern=(Math.random()<0.55)?2:3;
      shootBossSplit(b, pattern, 0, enemyBulletSpeed);
      if (hpRatio < 0.333 && Math.random() < 0.18) shootBossSplit(b, 3, 0, enemyBulletSpeed);
    }

    for (let bi=bullets.length-1; bi>=0; bi--){
      const bu=bullets[bi];
      let hit=null;
      for (const e of enemies){ if(e.alive && e.isBoss && aabb(bu,e)){ hit=e; break; } }
      if (hit){
        bullets.splice(bi,1);
        hit.hp -= 1;
        spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.0);
        if (hit.hp<=0){ hit.alive=false; spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.8); }
      }
    }

    for (let bi=enemyBullets.length-1; bi>=0; bi--){
      const b=enemyBullets[bi];
      if (aabb(b,player)){
        enemyBullets.splice(bi,1);
        spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
        endLose();
        break;
      }
    }
  }

  // ===== Secret boss =====
  function updateSecretBoss(dt){
    if (secret.messageTimer > 0) secret.messageTimer -= dt;
    if (secret.invulnTimer > 0) secret.invulnTimer -= dt;

    const W=window.innerWidth, H=window.innerHeight;

    if (secret.phase === 1){
      const top = clamp(H*0.18, 90, 170);
      const bottom = H*0.68;
      const left = 10, right = W-10;

      for (const m of secret.minions){
        if (!m.alive) continue;

        m.x += m.vx * dt;
        m.y += m.vy * dt;

        if (m.x < left){ m.x=left; m.vx *= -1; }
        if (m.x + m.w > right){ m.x = right - m.w; m.vx *= -1; }
        if (m.y < top){ m.y=top; m.vy *= -1; }
        if (m.y + m.h > bottom){ m.y = bottom - m.h; m.vy *= -1; }

        const shootPerSec = baseShootChance * 2.0;
        if (Math.random() < shootPerSec*dt){
          if (m.role === "homing") {
            shootEnemy(m, { type:"homing", color:"#3b7bff", vy: enemyBulletSpeed*0.70, vx: rand(-20,20), homing: 1.35 });
          } else if (m.role === "wavy") {
            shootEnemy(m, { type:"wavy", color:"#ff3b3b", vy: enemyBulletSpeed*0.72, vx: rand(-20,20), amp: clamp(W*0.70, 220, 420), freq: rand(8.5, 11.8) });
          } else {
            shootEnemy(m, { type:"normal", color:"#fff", vy: enemyBulletSpeed*0.92 });
          }
        }
      }

      for (let bi=bullets.length-1; bi>=0; bi--){
        const bu=bullets[bi];
        let hit=null;
        for (const m of secret.minions){ if(m.alive && aabb(bu,m)){ hit=m; break; } }
        if (hit){
          bullets.splice(bi,1);
          hit.hp -= 1;
          spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 0.9);
          if (hit.hp<=0){ hit.alive=false; spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.3); }
        }
      }

      for (let bi=enemyBullets.length-1; bi>=0; bi--){
        const b=enemyBullets[bi];
        if (aabb(b,player)){
          enemyBullets.splice(bi,1);
          spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
          endLose();
          return;
        }
      }

      if (secret.minions.every(m => !m.alive)){
        secret.lastPhase = 2;
        startSecretAtPhase(2);
      }
      return;
    }

    const b = secret.main;
    if (!b || !b.alive) return;

    if (secret.phase === 2){
      bossPhaseTime += dt;

      const hpRatio = b.hp / b.maxHp;
      const anger = 1 + (1 - hpRatio)*1.15;

      const vx = inv.speed * 1.05 * anger * inv.dir;
      const nextMin = b.x + vx*dt;
      const nextMax = b.x + b.w + vx*dt;
      if (nextMin < 10 || nextMax > W-10) inv.dir *= -1;
      else b.x += vx*dt;
      b.y += Math.sin(bossPhaseTime*1.6) * 7 * dt;

      const splitVy = enemyBulletSpeed * 0.82;
      const redVy   = enemyBulletSpeed * 0.62;
      const blueVy  = enemyBulletSpeed * 0.54;

      const shootPerSec = baseShootChance * 3.05 * anger;
      if (Math.random() < shootPerSec*dt){
        let pattern=1;
        if (hpRatio>=0.666) pattern=1;
        else if (hpRatio>=0.333) pattern=(Math.random()<0.5)?1:2;
        else pattern=(Math.random()<0.55)?2:3;

        shootBossSplit(b, pattern, 0, splitVy);

        if (Math.random() < 0.48){
          shootEnemy(b, { type:"wavy", color:"#ff3b3b", vy:redVy, vx: rand(-20,20), amp: clamp(W*0.78, 240, 520), freq: rand(8.8, 12.2) });
        }
        if (Math.random() < 0.38){
          shootEnemy(b, { type:"homing", color:"#3b7bff", vy:blueVy, vx: rand(-20,20), homing: 1.35 });
        }
      }

      if (secret.invulnTimer <= 0){
        for (let bi=bullets.length-1; bi>=0; bi--){
          const bu=bullets[bi];
          if (aabb(bu,b)){
            bullets.splice(bi,1);
            b.hp -= 1;
            spawnExplosion(b.x+b.w/2, b.y+b.h/2, 1.0);
            if (b.hp < 30){
              spawnExplosion(b.x+b.w/2, b.y+b.h/2, 2.0);
              secret.lastPhase = 3;
              startSecretAtPhase(3);
              return;
            }
          }
        }
      }

      for (let bi=enemyBullets.length-1; bi>=0; bi--){
        const eb=enemyBullets[bi];
        if (secret.invulnTimer <= 0 && aabb(eb,player)){
          enemyBullets.splice(bi,1);
          spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
          endLose();
          return;
        }
      }
      return;
    }

    // phase 3
    const areaTop = clamp(H*0.14, 80, 150);
    const areaBottom = H*0.62;
    const areaLeft = 10, areaRight = W-10;

    b.x += b.vx*dt;
    b.y += b.vy*dt;

    if (b.x < areaLeft){ b.x = areaLeft; b.vx *= -1; }
    if (b.x + b.w > areaRight){ b.x = areaRight - b.w; b.vx *= -1; }
    if (b.y < areaTop){ b.y = areaTop; b.vy *= -1; }
    if (b.y + b.h > areaBottom){ b.y = areaBottom - b.h; b.vy *= -1; }

    const hpRatio = b.hp / b.maxHp;
    const shootPerSec = baseShootChance * 3.10 * (1 + (1-hpRatio)*0.7);

    if (Math.random() < shootPerSec*dt){
      const pattern = (Math.random() < 0.55) ? 2 : 3;

      shootBossSplit(b, pattern, 0, enemyBulletSpeed*0.88);

      if (Math.random() < 0.18){
        shootEnemy(b, { type:"homing", color:"#3b7bff", vy: enemyBulletSpeed*0.62, vx: rand(-18,18), homing: 1.55 });
      }
      if (Math.random() < 0.24){
        shootEnemy(b, { type:"wavy", color:"#ff3b3b", vy: enemyBulletSpeed*0.66, vx: rand(-10,10), amp: clamp(W*0.90, 280, 640), freq: rand(9.5, 13.8) });
      }
    }

    if (secret.invulnTimer <= 0){
      for (let bi=bullets.length-1; bi>=0; bi--){
        const bu=bullets[bi];
        if (aabb(bu,b)){
          bullets.splice(bi,1);
          b.hp -= 1;
          spawnExplosion(b.x+b.w/2, b.y+b.h/2, 1.0);
          if (b.hp<=0){
            b.alive=false;
            spawnExplosion(b.x+b.w/2, b.y+b.h/2, 2.2);
            endSecretWin();
            return;
          }
        }
      }
    }

    for (let bi=enemyBullets.length-1; bi>=0; bi--){
      const eb=enemyBullets[bi];
      if (secret.invulnTimer <= 0 && aabb(eb,player)){
        enemyBullets.splice(bi,1);
        spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
        endLose();
        return;
      }
    }
  }

  // ===== Draw helpers =====
  function drawTextRainbow(text, x, y, size){
    ctx.save();
    ctx.textAlign = "center";
    ctx.font = `${size}px sans-serif`;

    const metrics = ctx.measureText(text);
    const w = Math.max(240, metrics.width);
    const grad = ctx.createLinearGradient(x - w/2, y, x + w/2, y);
    grad.addColorStop(0.00, "#ff2d2d");
    grad.addColorStop(0.17, "#ff9f0a");
    grad.addColorStop(0.33, "#ffd60a");
    grad.addColorStop(0.50, "#34c759");
    grad.addColorStop(0.67, "#32ade6");
    grad.addColorStop(0.83, "#0a84ff");
    grad.addColorStop(1.00, "#bf5af2");

    ctx.lineWidth = Math.max(3, Math.floor(size * 0.08));
    ctx.strokeStyle = "rgba(0,0,0,0.65)";
    ctx.strokeText(text, x, y);

    ctx.fillStyle = grad;
    ctx.fillText(text, x, y);
    ctx.restore();
    ctx.textAlign = "left";
  }

  function drawTutorial(){
    const W=window.innerWidth, H=window.innerHeight;
    const boxW = Math.floor(clamp(W*0.82, 260, 520));
    const boxH = Math.floor(clamp(H*0.30, 180, 260));
    const x = Math.floor((W - boxW)/2);
    const y = Math.floor((H - boxH)/2);

    ctx.globalAlpha = 0.92;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.strokeRect(x,y,boxW,boxH);
    ctx.globalAlpha = 1;

    ctx.fillStyle="#fff";
    ctx.textAlign="center";
    ctx.font="16px sans-serif";
    ctx.fillText("操作方法", W/2, y+34);

    ctx.font="14px sans-serif";
    const lines=[
      "左下を押す：左に移動",
      "右下を押す：右に移動",
      "（発射はオート）",
      "",
      "タップで開始"
    ];
    let yy=y+64;
    for(const line of lines){ ctx.fillText(line, W/2, yy); yy+=22; }
    ctx.textAlign="left";
  }

  function drawHPBar(label, hp, maxHp){
    const W=window.innerWidth;
    const top=64;
    const totalWidth = Math.floor(clamp(W*0.70, 260, 520));
    const barH=10;

    const x=Math.floor((W-totalWidth)/2);
    const y=top;

    ctx.globalAlpha=0.9;
    ctx.strokeStyle="#fff";
    ctx.strokeRect(x,y,totalWidth,barH);

    const ratio = clamp(hp/maxHp, 0, 1);
    ctx.globalAlpha=0.85;
    ctx.fillStyle="#fff";
    ctx.fillRect(x,y,Math.floor(totalWidth*ratio),barH);

    ctx.globalAlpha=0.75;
    ctx.fillStyle="#fff";
    ctx.font="12px sans-serif";
    ctx.textAlign="left";
    ctx.fillText(`${label}  HP ${hp}/${maxHp}`, x, y-4);
    ctx.globalAlpha=1;
    ctx.textAlign="left";
  }

  // ===== Draw =====
  function draw(){
    const W=window.innerWidth, H=window.innerHeight;
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha=0.18;
    ctx.fillStyle="#fff";
    for(let i=0;i<46;i++){
      const x=(i*97)%W, y=(i*173)%H;
      ctx.fillRect(x,y,1,1);
    }
    ctx.globalAlpha=1;

    if (state.screen === "tutorial"){
      drawTutorial();
      return;
    }

    // ★ステージ3クリア後：あけおめ！！だけ（余計な文言なし）
    if (state.screen === "stage3clear"){
      for (const c of confetti){
        ctx.globalAlpha = 0.75 * (1 - c.life/c.ttl);
        ctx.fillStyle = "#fff";
        ctx.fillRect(c.x, c.y, c.w, c.h);
      }
      ctx.globalAlpha = 1;

      drawTextRainbow("あけおめ！！", W/2, H*0.38, Math.floor(clamp(W*0.13, 48, 96)));
      return;
    }

    if (state.screen === "secretWarn"){
      const boxW = Math.floor(clamp(W*0.86, 280, 620));
      const boxH = Math.floor(clamp(H*0.32, 210, 320));
      const x = Math.floor((W-boxW)/2);
      const y = Math.floor((H-boxH)/2);

      ctx.globalAlpha=0.92;
      ctx.strokeStyle="#fff";
      ctx.lineWidth=2;
      ctx.strokeRect(x,y,boxW,boxH);
      ctx.globalAlpha=1;

      ctx.fillStyle="#fff";
      ctx.textAlign="center";
      ctx.font="16px sans-serif";
      ctx.fillText("注意", W/2, y+34);

      ctx.font="14px sans-serif";
      const lines=[
        "この裏ボスはかなり難しいし理不尽です。",
        "完全に自己満足の域なのでご自由にどうぞ。",
        "",
        "（押したら戻れない）"
      ];
      let yy=y+66;
      for(const line of lines){
        ctx.fillText(line, W/2, yy);
        yy += 22;
      }
      ctx.textAlign="left";
      return;
    }

    // HUD
    ctx.fillStyle="#fff";
    ctx.font="16px sans-serif";
    const stageName = (state.stage===3) ? "SECRET" : stages[state.stage].name;
    ctx.fillText(stageName, 12, 24);

    ctx.globalAlpha=0.75;
    ctx.font="12px sans-serif";
    if (touchMode) ctx.fillText("下の左右：移動（発射はオート）", 12, H-12);
    else ctx.fillText("←→/A D 移動（発射はオート）", 12, H-12);
    ctx.globalAlpha=1;

    // HP bars
    if (state.stage === 2){
      const bosses = enemies.filter(e=>e.alive && e.isBoss);
      if (bosses.length){
        const hp = bosses.reduce((s,b)=>s+b.hp,0);
        const mx = bosses.reduce((s,b)=>s+b.maxHp,0);
        drawHPBar("PHOENIX", hp, mx);
      }
    }
    if (state.stage === 3 && secret.main && secret.main.alive){
      const label =
        (secret.phase===1) ? "BURNING HORSE（無敵）" :
        (secret.phase===2) ? "BURNING HORSE" :
        "BURNING HORSE（FINAL）";
      drawHPBar(label, secret.main.hp, secret.main.maxHp);
      // ★「無敵時間…」などの演出テキストは出さない
    }

    // player
    ctx.fillStyle="#fff";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x + player.w/2 - 6, player.y - 7, 12, 7);

    // bullets
    ctx.fillStyle="#fff";
    for (const b of bullets) ctx.fillRect(b.x,b.y,b.w,b.h);

    for (const b of enemyBullets){
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = b.color || "#fff";
      ctx.fillRect(b.x,b.y,b.w,b.h);
    }
    ctx.globalAlpha=1;

    // enemies draw
    if (state.stage===0 || state.stage===1 || state.stage===2){
      const img = getImgForStage(state.stage);
      for (const e of enemies){
        if(!e.alive) continue;
        if(img) ctx.drawImage(img, e.x,e.y,e.w,e.h);
        else { ctx.strokeStyle="#fff"; ctx.strokeRect(e.x,e.y,e.w,e.h); }
        if (!e.isBoss && e.maxHp>1){
          ctx.globalAlpha=0.75;
          ctx.fillStyle="#fff";
          ctx.font="12px sans-serif";
          ctx.textAlign="center";
          ctx.fillText("II", e.x+e.w/2, e.y-4);
          ctx.textAlign="left";
          ctx.globalAlpha=1;
        }
      }
    } else {
      const mainImg = getImgForStage(3);
      const minionImg = getImgForStage(2);

      if (secret.main && secret.main.alive){
        if (mainImg) ctx.drawImage(mainImg, secret.main.x, secret.main.y, secret.main.w, secret.main.h);
        else { ctx.strokeStyle="#fff"; ctx.strokeRect(secret.main.x,secret.main.y,secret.main.w,secret.main.h); }

        if (secret.phase===1){
          ctx.globalAlpha=0.85;
          ctx.fillStyle="#fff";
          ctx.font="12px sans-serif";
          ctx.textAlign="center";
          ctx.fillText("無敵（手下を倒せ）", secret.main.x+secret.main.w/2, secret.main.y-10);
          ctx.textAlign="left";
          ctx.globalAlpha=1;
        }
      }

      if (secret.phase===1){
        for (const m of secret.minions){
          if(!m.alive) continue;
          if (minionImg) ctx.drawImage(minionImg, m.x,m.y,m.w,m.h);
          else { ctx.strokeStyle="#fff"; ctx.strokeRect(m.x,m.y,m.w,m.h); }
        }
      }

      // ★第二形態…/第三形態… などの演出表示は削除
    }

    // end overlay
    if (state.screen === "end"){
      ctx.fillStyle="rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle="#fff";
      ctx.textAlign="center";
      ctx.font="28px sans-serif";

      if (state.endKind === "lose"){
        ctx.fillText("GAME OVER", W/2, H/2 - 44);
        ctx.font="16px sans-serif";
        ctx.fillText("ボタンでやりなおす", W/2, H/2 - 14);
      } else if (state.endKind === "secretLose"){
        ctx.fillText("裏ボス敗北…", W/2, H/2 - 44);
        ctx.font="16px sans-serif";
        ctx.fillText("再開方法を選んでください（HPは毎回MAX回復）", W/2, H/2 - 14);
      } else if (state.endKind === "secretWin"){
        ctx.fillText("CLEAR!", W/2, H/2 - 44);
        ctx.font="18px sans-serif";
        ctx.fillText("おめでとう！！！君は今年中幸せだ！！", W/2, H/2 - 10);
      } else {
        ctx.fillText("CLEAR!", W/2, H/2 - 44);
        ctx.font="16px sans-serif";
        ctx.fillText("ボタンで周回", W/2, H/2 - 14);
      }
      ctx.textAlign="left";
    }

    // touch overlay
    if (touchMode && state.running){
      ctx.globalAlpha=0.16;
      ctx.strokeStyle="#fff";
      ctx.beginPath();
      ctx.moveTo(W/2,H*0.72); ctx.lineTo(W/2,H);
      ctx.moveTo(0,H*0.72); ctx.lineTo(W,H*0.72);
      ctx.stroke();

      ctx.globalAlpha=0.22;
      ctx.fillStyle="#fff";
      ctx.font="18px sans-serif";
      ctx.textAlign="center";
      ctx.fillText("◀︎", W*0.25, H*0.87);
      ctx.fillText("▶︎", W*0.75, H*0.87);
      ctx.textAlign="left";
      ctx.globalAlpha=1;
    }
  }

  // ===== Boot =====
  applyScreenAwareTuning();
  resetPlayer();
  hideButtons();
  showPrimary("はじめる", startGame);

  state.screen = "tutorial";
  state.running = false;

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
