<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>馬インベーダー</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    .btn{
      position: fixed;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 18px;
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.80);
      background: rgba(0,0,0,0.78);
      color: #fff;
      display: none;
      z-index: 10;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      cursor: pointer;
    }
    .btn:active { transform: translate(-50%, -50%) scale(0.98); }
    #primaryBtn { top: 62%; }
    #secondaryBtn { top: 72%; font-size: 14px; opacity: 0.9; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<button id="primaryBtn" class="btn">やりなおす</button>
<button id="secondaryBtn" class="btn">　</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const primaryBtn = document.getElementById("primaryBtn");
  const secondaryBtn = document.getElementById("secondaryBtn");

  // ===== Utils =====
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();
  const rand = (a,b) => a + Math.random()*(b-a);

  // ===== Resize =====
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", () => {
    resize();
    applyScreenAwareTuning();
    reflowForStage();
  }, { passive: true });
  resize();

  // ===== Assets =====
  const stages = [
    { name: "STAGE 1", src: "horse1.png" },
    { name: "STAGE 2", src: "horse2.png" },
    { name: "BOSS",    src: "phoenix.png" },
    { name: "SECRET",  src: "secret.png" }, // optional
  ];

  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ ok:true, img });
      img.onerror = () => resolve({ ok:false, img:null });
      img.src = src;
    });
  }

  const stageImages = Array(stages.length).fill(null);
  (async () => {
    for (let i = 0; i < stages.length; i++) stageImages[i] = await loadImage(stages[i].src);
  })();

  function getImgForStage(stageIndex) {
    if (stageIndex === 3) {
      const rec = stageImages[3];
      if (rec && rec.ok) return rec.img;
      const alt = stageImages[2];
      return (alt && alt.ok) ? alt.img : null;
    }
    const rec = stageImages[stageIndex];
    return (rec && rec.ok) ? rec.img : null;
  }

  // ===== State =====
  // screen:
  //  tutorial
  //  play
  //  stage3clear (あけおめ + 裏ボスへGO)
  //  secretWarn (注意書き)
  //  end (通常クリア/ゲームオーバー/裏ボスクリア)
  const state = {
    screen: "tutorial",
    running: false,
    stage: 0,      // 0:stage1, 1:stage2, 2:boss, 3:secret
    won: false,
    lost: false,
    endKind: "",   // "lose" | "win" | "secretWin"
    time: 0,
  };

  // ===== Player =====
  const player = {
    w: 52, h: 20,
    x: 0, y: 0,
    speed: 500,
    cooldownMs: 130,
    lastShotAt: -1e9,
  };

  // ===== Bullets =====
  const bullets = [];      // player bullets
  const enemyBullets = []; // enemy bullets: may have color, type, behavior
  let bulletSpeed = 760;
  let enemyBulletSpeed = 320;

  // ===== Explosions / Confetti =====
  const explosions = [];
  const confetti = [];
  function spawnExplosion(x,y,power=1) {
    const ttl = 0.42;
    const parts = [];
    const n = Math.floor(20 * power);
    for (let i=0;i<n;i++){
      const a = (Math.PI*2)*(i/n) + (Math.random()-0.5)*0.25;
      const sp = (90 + Math.random()*240) * power;
      parts.push({ x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:0, ttl:0.20+Math.random()*0.35 });
    }
    explosions.push({ x,y, life:0, ttl, parts });
  }
  function spawnConfettiBurst() {
    const W = window.innerWidth, H = window.innerHeight;
    for (let i=0;i<120;i++){
      confetti.push({
        x: W/2 + rand(-60,60),
        y: H*0.35 + rand(-40,40),
        vx: rand(-220,220),
        vy: rand(-260,80),
        life: 0,
        ttl: rand(0.9, 1.6),
        w: rand(2,5),
        h: rand(6,12),
      });
    }
  }

  // ===== Enemies =====
  const enemies = []; // stage 1-2 and boss: {x,y,w,h,alive,hp,maxHp,isBoss,row,col}
  const inv = {
    cols: 6, rows: 4,
    w: 64, h: 48,
    gapX: 18, gapY: 16,
    offsetX: 0, offsetY: 92,
    dir: 1,
    speed: 52,
  };

  // ===== Boss / Secret system =====
  let bossPhaseTime = 0;

  const bossNormal = { count:2, hp:30, shootMult:2.40 }; // ←ステージ3の発射頻度ダウン
  const secret = {
    phase: 1, // 1,2,3
    main: null,      // {x,y,w,h,hp,maxHp,alive, invuln}
    minions: [],     // [{x,y,w,h,hp,maxHp,alive,vx,vy}]
    phaseTimer: 0,
    messageTimer: 0, // 形態移行の短い演出時間
  };

  // ===== Input =====
  const keys = { left:false, right:false, shoot:false };

  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = true;
    if (e.code === "Space" || e.code === "KeyZ") keys.shoot = true;

    if (e.code === "Enter") {
      if (state.screen === "tutorial") startGame();
      else if (state.screen === "stage3clear") goSecretWarn();
      else if (state.screen === "secretWarn") startSecret();
      else if (state.screen === "end") handleEndPrimary();
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = false;
    if (e.code === "Space" || e.code === "KeyZ") keys.shoot = false;
  });

  let touchMode=false, touchLeft=false, touchRight=false, touchShoot=false;
  function resetTouch(){ touchLeft=touchRight=touchShoot=false; }
  function handleTouch(clientX, clientY, isDown) {
    touchMode=true;
    const W=window.innerWidth, H=window.innerHeight;
    const x=clamp(clientX,0,W), y=clamp(clientY,0,H);
    resetTouch();
    if(!isDown) return;
    const moveZoneTop = H*0.72;
    if(y >= moveZoneTop){
      if(x < W*0.5) touchLeft=true;
      else touchRight=true;
    } else {
      touchShoot=true;
    }
  }

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);

    if (state.screen === "tutorial") { startGame(); return; }
    if (state.screen === "stage3clear") { goSecretWarn(); return; }
    if (state.screen === "secretWarn") { startSecret(); return; }
    if (state.screen === "end") { handleEndPrimary(); return; }

    if (!state.running) return;
    handleTouch(e.clientX, e.clientY, true);
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!state.running) return;
    handleTouch(e.clientX, e.clientY, e.buttons === 1);
  });
  canvas.addEventListener("pointerup", () => resetTouch());

  // ===== Buttons =====
  function hideButtons(){
    primaryBtn.style.display = "none";
    secondaryBtn.style.display = "none";
    primaryBtn.onclick = null;
    secondaryBtn.onclick = null;
  }
  function showPrimary(text, onClick){
    primaryBtn.textContent = text;
    primaryBtn.style.display = "block";
    primaryBtn.onclick = onClick;
  }
  function showSecondary(text, onClick){
    secondaryBtn.textContent = text;
    secondaryBtn.style.display = "block";
    secondaryBtn.onclick = onClick;
  }

  // ===== Tuning =====
  let baseShootChance = 0.14;

  function applyScreenAwareTuning() {
    const W=window.innerWidth, H=window.innerHeight;
    const minDim = Math.min(W,H);

    const isStage2 = (state.stage === 1);
    inv.cols = isStage2 ? 4 : 6;
    inv.rows = isStage2 ? 3 : 4;

    const enemyScale = isStage2 ? 0.16 : 0.13;
    inv.w = Math.floor(clamp(W*enemyScale, 54, 110));
    inv.h = Math.floor(inv.w*0.78);
    inv.gapX = Math.floor(clamp(inv.w*0.35, 14, 30));
    inv.gapY = Math.floor(clamp(inv.h*0.32, 10, 26));
    inv.speed = clamp(W*0.10, 30, 78);

    player.w = Math.floor(clamp(W*0.15, 48, 74));
    player.h = Math.floor(clamp(player.w*0.40, 18, 28));
    player.speed = clamp(W*1.15, 360, 760);

    bulletSpeed = clamp(H*1.18, 620, 920);
    enemyBulletSpeed = clamp(H*0.60, 260, 520);

    baseShootChance = clamp(0.10 + (minDim/900)*0.08, 0.10, 0.20);
    player.cooldownMs = touchMode ? 120 : 130;
  }

  // ===== Spawn / Restart =====
  function resetPlayer(){
    player.x = (window.innerWidth - player.w)/2;
    player.y = window.innerHeight - player.h - 54;
    player.lastShotAt = -1e9;
  }

  function spawnFormation(){
    enemies.length=0;
    inv.dir=1;

    const totalW = inv.cols*inv.w + (inv.cols-1)*inv.gapX;
    inv.offsetX = (window.innerWidth - totalW)/2;
    inv.offsetY = Math.floor(clamp(window.innerHeight*0.14, 70, 130));

    const isStage2 = (state.stage===1);

    for(let r=0;r<inv.rows;r++){
      for(let c=0;c<inv.cols;c++){
        const hp = (isStage2 && (r===0 || r===inv.rows-1)) ? 2 : 1;
        enemies.push({
          x: inv.offsetX + c*(inv.w+inv.gapX),
          y: inv.offsetY + r*(inv.h+inv.gapY),
          w: inv.w, h: inv.h,
          alive:true,
          hp, maxHp:hp,
          isBoss:false,
          row:r, col:c
        });
      }
    }
  }

  function spawnBossNormal(){
    enemies.length=0;
    inv.dir=1;
    bossPhaseTime=0;

    const W=window.innerWidth, H=window.innerHeight;
    const bw = Math.floor(clamp(W*0.20, 90, 160));
    const bh = Math.floor(bw*0.78);
    const y = Math.floor(clamp(H*0.18, 90, 170));
    const x1 = Math.floor(W*0.33 - bw/2);
    const x2 = Math.floor(W*0.67 - bw/2);

    for(let i=0;i<bossNormal.count;i++){
      enemies.push({
        x: i===0?x1:x2,
        y,
        w:bw, h:bh,
        alive:true,
        hp: bossNormal.hp,
        maxHp: bossNormal.hp,
        isBoss:true,
        row:0, col:i
      });
    }
  }

  function setupSecretPhase1(){
    secret.phase = 1;
    secret.phaseTimer = 0;
    secret.messageTimer = 0;
    enemyBullets.length = 0;
    bullets.length = 0;
    explosions.length = 0;

    const W=window.innerWidth, H=window.innerHeight;
    const bw = Math.floor(clamp(W*0.26, 120, 240));
    const bh = Math.floor(bw*0.78);

    secret.main = {
      x: Math.floor(W*0.5 - bw/2),
      y: Math.floor(clamp(H*0.18, 90, 170)),
      w:bw, h:bh,
      alive:true,
      hp: 80,
      maxHp: 80,
      invuln: true
    };

    secret.minions = [];
    for(let i=0;i<3;i++){
      const mw = Math.floor(clamp(W*0.16, 90, 160));
      const mh = Math.floor(mw*0.78);
      secret.minions.push({
        x: Math.floor(W*0.18 + i*(W*0.24)),
        y: Math.floor(clamp(H*0.38, 220, 320)),
        w: mw, h: mh,
        alive:true,
        hp: 18,
        maxHp: 18,
        vx: rand(-220,220),
        vy: rand(-170,170)
      });
    }
  }

  function setupSecretPhase2(){
    secret.phase = 2;
    secret.phaseTimer = 0;
    secret.messageTimer = 0.55; // ちょい演出
    enemyBullets.length = 0;
    bullets.length = 0;
    explosions.length = 0;

    secret.main.invuln = false;
    // HPはそのまま（残し）でもいいけど、理不尽すぎ防止で少し回復
    secret.main.hp = Math.min(secret.main.maxHp, secret.main.hp + 25);
  }

  function setupSecretPhase3(){
    secret.phase = 3;
    secret.phaseTimer = 0;
    secret.messageTimer = 0.55;
    enemyBullets.length = 0;
    bullets.length = 0;
    explosions.length = 0;

    const W=window.innerWidth, H=window.innerHeight;
    const nw = Math.floor(clamp(W*0.14, 70, 120));
    const nh = Math.floor(nw*0.78);

    secret.main.w = nw;
    secret.main.h = nh;
    secret.main.x = Math.floor(W*0.5 - nw/2);
    secret.main.y = Math.floor(clamp(H*0.22, 110, 190));
    secret.main.hp = 28;
    secret.main.maxHp = 28;
    secret.main.invuln = false;

    // phase3 speed
    secret.main.vx = rand(-420,420);
    secret.main.vy = rand(-320,320);
  }

  function restartPlayStage(){
    applyScreenAwareTuning();
    state.running = true;
    state.won = false;
    state.lost = false;
    hideButtons();
    resetTouch();
    resetPlayer();
    bullets.length = 0;
    enemyBullets.length = 0;
    explosions.length = 0;
    confetti.length = 0;

    if (state.stage === 0 || state.stage === 1) spawnFormation();
    else if (state.stage === 2) spawnBossNormal();
    else { /* secret uses secret system */ setupSecretPhase1(); }
  }

  function startGame(){
    state.screen = "play";
    state.stage = 0;
    state.running = true;
    hideButtons();
    restartPlayStage();
  }

  function goSecretWarn(){
    // stage3clearから遷移
    state.screen = "secretWarn";
    state.running = false;
    hideButtons();
    showPrimary("裏ボス開始", startSecret);
    showSecondary("やめとく", () => { // 周回へ
      state.screen = "end";
      state.endKind = "win";
      state.won = true;
      state.lost = false;
      showPrimary("もう一回", () => { state.stage = 0; restartPlayStage(); state.screen="play"; });
      showSecondary("", null);
      secondaryBtn.style.display = "none";
    });
  }

  function startSecret(){
    state.stage = 3;
    state.screen = "play";
    state.running = true;
    state.won = false;
    state.lost = false;
    hideButtons();
    resetTouch();
    resetPlayer();
    setupSecretPhase1();
  }

  function handleEndPrimary(){
    // end画面のボタン
    if (state.endKind === "lose") {
      state.screen = "play";
      state.running = true;
      restartPlayStage();
      return;
    }
    if (state.endKind === "win") {
      // 周回
      state.stage = 0;
      state.screen = "play";
      state.running = true;
      restartPlayStage();
      return;
    }
    if (state.endKind === "secretWin") {
      state.stage = 0;
      state.screen = "play";
      state.running = true;
      restartPlayStage();
      return;
    }
  }

  function reflowForStage(){
    // 回転時の保険：play中のみ軽く整える
    if (state.screen !== "play") return;
    if (state.stage === 0 || state.stage === 1 || state.stage === 2) {
      // 既存は崩れにくいので、再起動級の再配置はしない
      // 代わりに自機位置だけ補正
      resetPlayer();
    } else {
      resetPlayer();
    }
  }

  // ===== Shooting =====
  function shootPlayer(tms){
    if (tms - player.lastShotAt < player.cooldownMs) return;
    player.lastShotAt = tms;
    bullets.push({ x: player.x + player.w/2 - 2, y: player.y - 10, w: 4, h: 10, vx: 0, vy: -bulletSpeed });
  }

  function shootEnemy(from, opt = {}){
    enemyBullets.push({
      x: from.x + from.w/2 - 2,
      y: from.y + from.h + 2,
      w: 4, h: 10,
      vx: opt.vx || 0,
      vy: opt.vy || enemyBulletSpeed,
      type: opt.type || "normal",     // normal / delayed / split / wavy / homing
      color: opt.color || "#fff",
      age: 0,
      splitAt: opt.splitAt ?? 0.28,
      splitDone: false,
      pattern: opt.pattern || null,   // for split
      amp: opt.amp || 0,
      freq: opt.freq || 0,
      homing: opt.homing || 0,        // 0..1
    });
  }

  function shootEnemyDouble(from){
    shootEnemy(from, { type:"normal" });
    shootEnemy(from, { type:"delayed", vy: enemyBulletSpeed, color:"#fff", });
    enemyBullets[enemyBullets.length-1].age = -0.12;
    enemyBullets[enemyBullets.length-1].splitDone = true;
  }

  function shootBossSplit(from, pattern, extraVx=0){
    shootEnemy(from, { type:"split", splitAt:0.24, vx:extraVx, pattern, color:"#fff" });
  }

  // ===== Collision =====
  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // ===== Update / Draw loop =====
  let last = now();

  function step(){
    const t=now();
    const dt=Math.min(0.033, (t-last)/1000);
    last=t;
    state.time += dt;

    if (state.screen === "play" && state.running) update(dt, t);
    draw();
    requestAnimationFrame(step);
  }

  function update(dt, tms){
    applyScreenAwareTuning();

    const left  = keys.left  || touchLeft;
    const right = keys.right || touchRight;
    const shoot = keys.shoot || touchShoot;

    // player move
    let vx=0;
    if(left) vx -= player.speed;
    if(right) vx += player.speed;
    player.x = clamp(player.x + vx*dt, 10, window.innerWidth - player.w - 10);

    if(shoot) shootPlayer(tms);

    // move player bullets
    for (const b of bullets){
      b.x += (b.vx||0)*dt;
      b.y += b.vy*dt;
    }

    // move enemy bullets with behaviors
    for (let i=enemyBullets.length-1;i>=0;i--){
      const b = enemyBullets[i];
      b.age += dt;

      if (b.type === "delayed") {
        if (b.age < 0) continue;
        b.type = "normal";
      }

      // wavy: x oscillates
      if (b.type === "wavy") {
        const ox = Math.sin(b.age * b.freq) * b.amp;
        b.x += (b.vx||0)*dt + ox*dt; // small drift
      } else if (b.type === "homing") {
        const px = player.x + player.w/2;
        const bx = b.x + b.w/2;
        const dx = clamp(px - bx, -260, 260);
        b.vx += (dx * b.homing) * dt;
        b.vx = clamp(b.vx, -220, 220);
        b.x += b.vx * dt;
      } else {
        b.x += (b.vx||0)*dt;
      }
      b.y += b.vy*dt;

      // split bullets
      if (b.type === "split" && !b.splitDone && b.age >= b.splitAt) {
        b.splitDone = true;

        const pattern = b.pattern || 1;
        const base = clamp(window.innerWidth * 0.22, 170, 360);
        const slow = base * 0.55;

        const spawnChild = (vxChild) => shootEnemy({x:b.x, y:b.y, w:0,h:0}, { vx:vxChild, vy:b.vy, type:"normal", color:"#fff" });

        if (pattern === 1) { spawnChild(-base); spawnChild(+base); }
        else if (pattern === 2) { spawnChild(-slow); spawnChild(-base); spawnChild(+slow); spawnChild(+base); }
        else { spawnChild(-base); spawnChild(0); spawnChild(+base); }

        enemyBullets.splice(i,1);
        continue;
      }

      if (b.y > window.innerHeight + 100 || b.x < -120 || b.x > window.innerWidth + 120) enemyBullets.splice(i,1);
    }

    // cleanup player bullets
    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if (b.y + b.h < -80) bullets.splice(i,1);
    }

    // explosions update
    for (let i=explosions.length-1;i>=0;i--){
      const ex=explosions[i];
      ex.life += dt;
      for (const p of ex.parts){
        p.life += dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= (1 - 2.8*dt);
        p.vy *= (1 - 2.8*dt);
      }
      if (ex.life >= ex.ttl) explosions.splice(i,1);
    }

    // confetti update
    for (let i=confetti.length-1;i>=0;i--){
      const c=confetti[i];
      c.life += dt;
      c.x += c.vx*dt;
      c.y += c.vy*dt;
      c.vy += 420*dt;
      c.vx *= (1 - 0.8*dt);
      if (c.life >= c.ttl) confetti.splice(i,1);
    }

    // stage logic
    if (state.stage === 0 || state.stage === 1) updateStage12(dt, tms);
    else if (state.stage === 2) updateBossNormal(dt, tms);
    else updateSecretBoss(dt, tms);

    // tap shoot momentary
    touchShoot = false;
  }

  function endLose(){
    state.running = false;
    state.won = false;
    state.lost = true;
    state.screen = "end";
    state.endKind = "lose";
    hideButtons();
    showPrimary("やりなおす", handleEndPrimary);
  }

  function endWinNormal(){
    state.running = false;
    state.won = true;
    state.lost = false;
    state.screen = "end";
    state.endKind = "win";
    hideButtons();
    showPrimary("もう一回", handleEndPrimary);
  }

  function endSecretWin(){
    state.running = false;
    state.won = true;
    state.lost = false;
    state.screen = "end";
    state.endKind = "secretWin";
    hideButtons();
    showPrimary("もう一回", handleEndPrimary);
  }

  // ===== Stage 1-2 =====
  function updateFormationMovement(dt, aliveInv){
    const isStage2 = (state.stage === 1);

    if (!isStage2) {
      // stage1 all move
      const movers = aliveInv;
      let minX=Infinity, maxX=-Infinity;
      for (const e of movers){ minX=Math.min(minX,e.x); maxX=Math.max(maxX,e.x+e.w); }
      const remainRatio = aliveInv.length / (inv.cols*inv.rows);
      const thinBoost = 1 + (1 - remainRatio)*0.9;
      const vx = inv.speed * thinBoost * inv.dir;

      const nextMin = minX + vx*dt;
      const nextMax = maxX + vx*dt;

      if (nextMin < 10 || nextMax > window.innerWidth - 10) inv.dir *= -1;
      else for (const e of movers) e.x += vx*dt;
      return;
    }

    // stage2 only top row moves
    const movers = aliveInv.filter(e => e.row === 0);
    if (movers.length === 0) return;

    let minX=Infinity, maxX=-Infinity;
    for (const e of movers){ minX=Math.min(minX,e.x); maxX=Math.max(maxX,e.x+e.w); }

    const remainRatio = aliveInv.length / (inv.cols*inv.rows);
    const thinBoost = 1 + (1 - remainRatio)*0.9;
    const vx = inv.speed * 1.55 * thinBoost * inv.dir;

    const nextMin = minX + vx*dt;
    const nextMax = maxX + vx*dt;

    if (nextMin < 10 || nextMax > window.innerWidth - 10) inv.dir *= -1;
    else for (const e of movers) e.x += vx*dt;
  }

  function updateFormationShooting(dt, aliveInv){
    const total = inv.cols*inv.rows;
    const remainRatio = aliveInv.length / total;
    const intensity = 1 + (1 - remainRatio)*0.7;

    const shootPerSec = (state.stage === 0 ? baseShootChance*1.90 : baseShootChance*1.15) * intensity;

    if (Math.random() < shootPerSec * dt){
      const col = Math.floor(Math.random()*inv.cols);
      let shooter=null;
      for(let r=inv.rows-1;r>=0;r--){
        const cand = enemies.find(e => e.alive && !e.isBoss && e.col===col && e.row===r);
        if (cand){ shooter=cand; break; }
      }
      if (shooter){
        if (state.stage===0) shootEnemy(shooter);
        else shootEnemyDouble(shooter);
      }
    }
  }

  function updateStage12(dt, tms){
    const alive = enemies.filter(e => e.alive);
    if (alive.length === 0){
      // clear stage1 -> stage2, clear stage2 -> boss
      state.running = false;
      state.won = true;
      state.lost = false;
      state.screen = "end";
      state.endKind = "win";
      hideButtons();

      showPrimary("つぎへ", () => {
        if (state.stage === 0) state.stage = 1;
        else state.stage = 2;
        state.screen = "play";
        restartPlayStage();
      });
      return;
    }

    updateFormationMovement(dt, alive);
    updateFormationShooting(dt, alive);

    // collisions
    // player bullets vs enemies
    for (let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      let hit=null;
      for (const e of enemies){ if(e.alive && aabb(b,e)){ hit=e; break; } }
      if (hit){
        bullets.splice(bi,1);
        hit.hp -= 1;
        spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 0.8);
        if (hit.hp<=0){ hit.alive=false; spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.1); }
      }
    }

    // enemy bullets vs player
    for (let bi=enemyBullets.length-1; bi>=0; bi--){
      const b=enemyBullets[bi];
      if (aabb(b,player)){
        enemyBullets.splice(bi,1);
        spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
        endLose();
        break;
      }
    }
  }

  // ===== Boss (Stage 3) =====
  function updateBossNormal(dt, tms){
    const aliveBosses = enemies.filter(e => e.alive && e.isBoss);
    if (aliveBosses.length === 0){
      // ★ここで「あけおめ！！」+ 裏ボスへGO
      state.running = false;
      state.screen = "stage3clear";
      hideButtons();
      showPrimary("裏ボスへGO", goSecretWarn);
      showSecondary("周回する", () => { state.screen="end"; endWinNormal(); });
      spawnConfettiBurst();
      return;
    }

    bossPhaseTime += dt;

    // movement (no approaching)
    let minX=Infinity, maxX=-Infinity;
    for (const b of aliveBosses){ minX=Math.min(minX,b.x); maxX=Math.max(maxX,b.x+b.w); }

    const hpSum = aliveBosses.reduce((s,b)=>s+b.hp,0);
    const maxSum = aliveBosses.reduce((s,b)=>s+b.maxHp,0);
    const hpRatio = maxSum>0 ? (hpSum/maxSum) : 0;

    const anger = 1 + (1 - hpRatio)*0.9;
    const vxBoss = inv.speed * 0.95 * anger * inv.dir;

    const nextMin = minX + vxBoss*dt;
    const nextMax = maxX + vxBoss*dt;

    if (nextMin<10 || nextMax>window.innerWidth-10) inv.dir *= -1;
    else for (const b of aliveBosses) b.x += vxBoss*dt;

    for (let i=0;i<aliveBosses.length;i++){
      const b=aliveBosses[i];
      b.y += Math.sin(bossPhaseTime*1.5 + i*2.2) * 6 * dt;
    }

    // shooting (frequency lowered by bossNormal.shootMult)
    const shootPerSec = baseShootChance * bossNormal.shootMult * (1 + (1-hpRatio)*1.10);
    if (Math.random() < shootPerSec*dt){
      const b = aliveBosses[Math.floor(Math.random()*aliveBosses.length)];
      let pattern=1;
      if (hpRatio>=0.666) pattern=1;
      else if (hpRatio>=0.333) pattern=(Math.random()<0.5)?1:2;
      else pattern=(Math.random()<0.55)?2:3;
      shootBossSplit(b, pattern);
      if (hpRatio < 0.333 && Math.random() < 0.18) shootBossSplit(b, 3, 0);
    }

    // collisions
    for (let bi=bullets.length-1; bi>=0; bi--){
      const bu=bullets[bi];
      let hit=null;
      for (const e of enemies){ if(e.alive && e.isBoss && aabb(bu,e)){ hit=e; break; } }
      if (hit){
        bullets.splice(bi,1);
        hit.hp -= 1;
        spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.0);
        if (hit.hp<=0){ hit.alive=false; spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.8); }
      }
    }

    for (let bi=enemyBullets.length-1; bi>=0; bi--){
      const b=enemyBullets[bi];
      if (aabb(b,player)){
        enemyBullets.splice(bi,1);
        spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
        endLose();
        break;
      }
    }
  }

  // ===== Secret Boss (3 phases) =====
  function updateSecretBoss(dt, tms){
    secret.phaseTimer += dt;
    if (secret.messageTimer > 0) secret.messageTimer -= dt;

    // phase clear / transitions
    if (secret.phase === 1){
      // move minions (they have no collision with player)
      const W=window.innerWidth, H=window.innerHeight;
      const top = clamp(H*0.18, 90, 170);
      const bottom = H*0.68;
      const left = 10, right = W-10;

      for (const m of secret.minions){
        if (!m.alive) continue;
        m.x += m.vx * dt;
        m.y += m.vy * dt;

        if (m.x < left){ m.x=left; m.vx *= -1; }
        if (m.x + m.w > right){ m.x = right - m.w; m.vx *= -1; }
        if (m.y < top){ m.y=top; m.vy *= -1; }
        if (m.y + m.h > bottom){ m.y = bottom - m.h; m.vy *= -1; }

        // shooting moderate
        const shootPerSec = baseShootChance * 2.0;
        if (Math.random() < shootPerSec*dt){
          shootEnemy(m, { type:"normal", color:"#fff", vy: enemyBulletSpeed*0.95 });
        }
      }

      // bullets vs minions
      for (let bi=bullets.length-1; bi>=0; bi--){
        const bu=bullets[bi];
        let hit=null;
        for (const m of secret.minions){ if(m.alive && aabb(bu,m)){ hit=m; break; } }
        if (hit){
          bullets.splice(bi,1);
          hit.hp -= 1;
          spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 0.9);
          if (hit.hp<=0){ hit.alive=false; spawnExplosion(hit.x+hit.w/2, hit.y+hit.h/2, 1.3); }
        }
      }

      // enemy bullets vs player (always lethal)
      for (let bi=enemyBullets.length-1; bi>=0; bi--){
        const b=enemyBullets[bi];
        if (aabb(b,player)){
          enemyBullets.splice(bi,1);
          spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
          endLose();
          return;
        }
      }

      // transition when all minions dead
      if (secret.minions.every(m => !m.alive)){
        setupSecretPhase2();
      }
      return;
    }

    // phase 2 and 3: main moves/attacks, takes damage
    const b = secret.main;
    if (!b || !b.alive) return;

    const W=window.innerWidth, H=window.innerHeight;

    // movement
    if (secret.phase === 2){
      // similar to boss but single
      bossPhaseTime += dt;
      const hpRatio = b.hp / b.maxHp;
      const anger = 1 + (1 - hpRatio)*1.15;

      const vx = inv.speed * 1.05 * anger * inv.dir;
      const nextMin = b.x + vx*dt;
      const nextMax = b.x + b.w + vx*dt;
      if (nextMin < 10 || nextMax > W-10) inv.dir *= -1;
      else b.x += vx*dt;

      b.y += Math.sin(bossPhaseTime*1.6) * 7 * dt;

      // shooting: stage3 patterns + wavy + homing
      const shootPerSec = baseShootChance * 3.10 * anger; // そこそこ鬼
      if (Math.random() < shootPerSec*dt){
        // 既存分裂
        let pattern=1;
        if (hpRatio>=0.666) pattern=1;
        else if (hpRatio>=0.333) pattern=(Math.random()<0.5)?1:2;
        else pattern=(Math.random()<0.55)?2:3;
        shootBossSplit(b, pattern);

        // くねくね弾(赤) 少し遅い
        if (Math.random() < 0.45){
          shootEnemy(b, {
            type:"wavy",
            color:"#ff3b3b",
            vy: enemyBulletSpeed*0.72,
            vx: rand(-40,40),
            amp: clamp(W*0.14, 80, 160),
            freq: rand(5.2, 8.2)
          });
        }

        // 追尾弾(青) 遅い
        if (Math.random() < 0.35){
          shootEnemy(b, {
            type:"homing",
            color:"#3b7bff",
            vy: enemyBulletSpeed*0.62,
            vx: rand(-40,40),
            homing: 0.85
          });
        }
      }

      // collisions bullets vs boss
      if (!b.invuln){
        for (let bi=bullets.length-1; bi>=0; bi--){
          const bu=bullets[bi];
          if (aabb(bu,b)){
            bullets.splice(bi,1);
            b.hp -= 1;
            spawnExplosion(b.x+b.w/2, b.y+b.h/2, 1.0);
            if (b.hp<=0){
              spawnExplosion(b.x+b.w/2, b.y+b.h/2, 2.0);
              setupSecretPhase3();
              return;
            }
          }
        }
      }

      // enemy bullets vs player
      for (let bi=enemyBullets.length-1; bi>=0; bi--){
        const eb=enemyBullets[bi];
        if (aabb(eb,player)){
          enemyBullets.splice(bi,1);
          spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
          endLose();
          return;
        }
      }
      return;
    }

    // phase 3: small + fast free movement, simple strong
    if (secret.phase === 3){
      const areaTop = clamp(H*0.14, 80, 150);
      const areaBottom = H*0.62;
      const areaLeft = 10, areaRight = W-10;

      // bounce move
      b.x += b.vx*dt;
      b.y += b.vy*dt;

      if (b.x < areaLeft){ b.x = areaLeft; b.vx *= -1; }
      if (b.x + b.w > areaRight){ b.x = areaRight - b.w; b.vx *= -1; }
      if (b.y < areaTop){ b.y = areaTop; b.vy *= -1; }
      if (b.y + b.h > areaBottom){ b.y = areaBottom - b.h; b.vy *= -1; }

      // shooting: faster but simpler
      const hpRatio = b.hp / b.maxHp;
      const shootPerSec = baseShootChance * 4.10 * (1 + (1-hpRatio)*0.8);
      if (Math.random() < shootPerSec*dt){
        // short split spam
        const pattern = (Math.random() < 0.55) ? 2 : 3;
        shootBossSplit(b, pattern);
        // occasional homing to be evil
        if (Math.random() < 0.28){
          shootEnemy(b, { type:"homing", color:"#3b7bff", vy: enemyBulletSpeed*0.62, vx: rand(-30,30), homing: 1.05 });
        }
      }

      // collisions
      for (let bi=bullets.length-1; bi>=0; bi--){
        const bu=bullets[bi];
        if (aabb(bu,b)){
          bullets.splice(bi,1);
          b.hp -= 1;
          spawnExplosion(b.x+b.w/2, b.y+b.h/2, 1.0);
          if (b.hp<=0){
            b.alive=false;
            spawnExplosion(b.x+b.w/2, b.y+b.h/2, 2.2);
            // secret win
            state.running=false;
            state.screen="end";
            state.endKind="secretWin";
            hideButtons();
            showPrimary("もう一回", handleEndPrimary);
            return;
          }
        }
      }

      for (let bi=enemyBullets.length-1; bi>=0; bi--){
        const eb=enemyBullets[bi];
        if (aabb(eb,player)){
          enemyBullets.splice(bi,1);
          spawnExplosion(player.x+player.w/2, player.y+player.h/2, 1.6);
          endLose();
          return;
        }
      }
      return;
    }
  }

  // ===== Draw =====
  function drawTextNeon(text, x, y, size, t){
    ctx.save();
    ctx.textAlign="center";
    ctx.fillStyle="#fff";
    ctx.font = `${size}px sans-serif`;
    const pulse = 0.55 + 0.45*Math.sin(t*6.0);
    ctx.globalAlpha = 0.40 + 0.25*pulse;
    ctx.lineWidth = 10;
    ctx.strokeStyle = "#fff";
    ctx.strokeText(text, x, y);
    ctx.globalAlpha = 0.85;
    ctx.fillText(text, x, y);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawTutorial(){
    const W=window.innerWidth, H=window.innerHeight;
    const boxW = Math.floor(clamp(W*0.82, 260, 520));
    const boxH = Math.floor(clamp(H*0.30, 180, 260));
    const x = Math.floor((W - boxW)/2);
    const y = Math.floor((H - boxH)/2);

    ctx.globalAlpha = 0.92;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.strokeRect(x,y,boxW,boxH);
    ctx.globalAlpha = 1;

    ctx.fillStyle="#fff";
    ctx.textAlign="center";
    ctx.font="16px sans-serif";
    ctx.fillText("操作方法", W/2, y+34);

    ctx.font="14px sans-serif";
    const lines=[
      "左下を押す：左に移動",
      "右下を押す：右に移動",
      "上側を押す：発射",
      "",
      "タップで開始"
    ];
    let yy=y+64;
    for(const line of lines){ ctx.fillText(line, W/2, yy); yy+=22; }
    ctx.textAlign="left";
  }

  function drawBossHPBars(label, list){
    const W=window.innerWidth;
    const top=64;
    const totalWidth = Math.floor(clamp(W*0.70, 260, 520));
    const barH=10;
    const gap=10;

    for(let i=0;i<list.length;i++){
      const b=list[i];
      const x=Math.floor((W-totalWidth)/2);
      const y=top + i*(barH+gap);

      ctx.globalAlpha=0.9;
      ctx.strokeStyle="#fff";
      ctx.strokeRect(x,y,totalWidth,barH);

      const ratio = clamp(b.hp/b.maxHp, 0, 1);
      ctx.globalAlpha=0.85;
      ctx.fillStyle="#fff";
      ctx.fillRect(x,y,Math.floor(totalWidth*ratio),barH);

      ctx.globalAlpha=0.75;
      ctx.fillStyle="#fff";
      ctx.font="12px sans-serif";
      ctx.textAlign="left";
      ctx.fillText(`${label}  HP ${b.hp}/${b.maxHp}`, x, y-4);
    }
    ctx.globalAlpha=1;
    ctx.textAlign="left";
  }

  function draw(){
    const W=window.innerWidth, H=window.innerHeight;
    ctx.clearRect(0,0,W,H);

    // bg
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    // stars
    ctx.globalAlpha=0.18;
    ctx.fillStyle="#fff";
    for(let i=0;i<46;i++){
      const x=(i*97)%W, y=(i*173)%H;
      ctx.fillRect(x,y,1,1);
    }
    ctx.globalAlpha=1;

    if (state.screen === "tutorial"){
      drawTutorial();
      return;
    }

    // stage3clear special screen (派手)
    if (state.screen === "stage3clear"){
      // confetti
      for (const c of confetti){
        ctx.globalAlpha = 0.75 * (1 - c.life/c.ttl);
        ctx.fillStyle = "#fff";
        ctx.fillRect(c.x, c.y, c.w, c.h);
      }
      ctx.globalAlpha = 1;

      drawTextNeon("あけおめ！！", W/2, H*0.35, Math.floor(clamp(W*0.12, 44, 84)), state.time);

      ctx.globalAlpha = 0.85;
      ctx.font = "14px sans-serif";
      ctx.textAlign="center";
      ctx.fillStyle="#fff";
      ctx.fillText("（ここから先は自己満足の世界）", W/2, H*0.43);
      ctx.textAlign="left";
      ctx.globalAlpha = 1;
      return;
    }

    // secret warn screen
    if (state.screen === "secretWarn"){
      // box
      const boxW = Math.floor(clamp(W*0.86, 280, 620));
      const boxH = Math.floor(clamp(H*0.32, 210, 300));
      const x = Math.floor((W-boxW)/2);
      const y = Math.floor((H-boxH)/2);

      ctx.globalAlpha=0.92;
      ctx.strokeStyle="#fff";
      ctx.lineWidth=2;
      ctx.strokeRect(x,y,boxW,boxH);
      ctx.globalAlpha=1;

      ctx.fillStyle="#fff";
      ctx.textAlign="center";
      ctx.font="16px sans-serif";
      ctx.fillText("注意", W/2, y+34);

      ctx.font="14px sans-serif";
      const lines=[
        "この裏ボスはかなり難しいし理不尽です。",
        "完全に自己満足の域なのでご自由にどうぞ。",
        "",
        "（押したら戻れない）"
      ];
      let yy=y+66;
      for(const line of lines){
        ctx.fillText(line, W/2, yy);
        yy += 22;
      }
      ctx.textAlign="left";
      return;
    }

    // HUD
    ctx.fillStyle="#fff";
    ctx.font="16px sans-serif";
    const stageName = (state.stage===3) ? "SECRET" : stages[state.stage].name;
    ctx.fillText(stageName, 12, 24);

    ctx.globalAlpha=0.75;
    ctx.font="12px sans-serif";
    if (touchMode) ctx.fillText("下の左右：移動 / 上をタップ：発射", 12, H-12);
    else ctx.fillText("←→/A D 移動  SPACE/Z 発射", 12, H-12);
    ctx.globalAlpha=1;

    // boss hp
    if (state.stage === 2){
      const bosses = enemies.filter(e=>e.alive && e.isBoss);
      if (bosses.length) drawBossHPBars("PHOENIX", bosses);
    }
    if (state.stage === 3){
      if (secret.main && secret.main.alive){
        const label = (secret.phase===1) ? "BURNING HORSE（無敵）" : (secret.phase===2 ? "BURNING HORSE" : "BURNING HORSE（FINAL）");
        drawBossHPBars(label, [{hp:secret.main.hp, maxHp:secret.main.maxHp}]);
      }
    }

    // player
    ctx.fillStyle="#fff";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x + player.w/2 - 6, player.y - 7, 12, 7);

    // bullets
    ctx.fillStyle="#fff";
    for (const b of bullets) ctx.fillRect(b.x,b.y,b.w,b.h);

    // enemy bullets with colors
    for (const b of enemyBullets){
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = b.color || "#fff";
      ctx.fillRect(b.x,b.y,b.w,b.h);
    }
    ctx.globalAlpha=1;

    // enemies draw
    if (state.stage===0 || state.stage===1 || state.stage===2){
      const img = getImgForStage(state.stage);
      for (const e of enemies){
        if(!e.alive) continue;
        if(img) ctx.drawImage(img, e.x,e.y,e.w,e.h);
        else { ctx.strokeStyle="#fff"; ctx.strokeRect(e.x,e.y,e.w,e.h); }
        if (!e.isBoss && e.maxHp>1){
          ctx.globalAlpha=0.75;
          ctx.fillStyle="#fff";
          ctx.font="12px sans-serif";
          ctx.textAlign="center";
          ctx.fillText("II", e.x+e.w/2, e.y-4);
          ctx.textAlign="left";
          ctx.globalAlpha=1;
        }
      }
    } else {
      // secret
      const mainImg = getImgForStage(3);
      const minionImg = getImgForStage(2);

      // main
      if (secret.main && secret.main.alive){
        if (mainImg) ctx.drawImage(mainImg, secret.main.x, secret.main.y, secret.main.w, secret.main.h);
        else { ctx.strokeStyle="#fff"; ctx.strokeRect(secret.main.x,secret.main.y,secret.main.w,secret.main.h); }

        // invuln marker phase1
        if (secret.phase===1){
          ctx.globalAlpha=0.85;
          ctx.fillStyle="#fff";
          ctx.font="12px sans-serif";
          ctx.textAlign="center";
          ctx.fillText("無敵（手下を倒せ）", secret.main.x+secret.main.w/2, secret.main.y-10);
          ctx.textAlign="left";
          ctx.globalAlpha=1;
        }
      }

      // minions
      if (secret.phase===1){
        for (const m of secret.minions){
          if(!m.alive) continue;
          if (minionImg) ctx.drawImage(minionImg, m.x,m.y,m.w,m.h);
          else { ctx.strokeStyle="#fff"; ctx.strokeRect(m.x,m.y,m.w,m.h); }
        }
      }

      // phase transition tiny text
      if (secret.messageTimer > 0){
        ctx.globalAlpha=0.85;
        ctx.fillStyle="#fff";
        ctx.textAlign="center";
        ctx.font="16px sans-serif";
        ctx.fillText(secret.phase===2 ? "第二形態…" : "第三形態…", W/2, H*0.55);
        ctx.textAlign="left";
        ctx.globalAlpha=1;
      }
    }

    // explosions
    for (const ex of explosions){
      const t = ex.life/ex.ttl;
      ctx.globalAlpha = 0.35*(1-t);
      ctx.strokeStyle="#fff";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(ex.x,ex.y,10+t*32,0,Math.PI*2);
      ctx.stroke();

      for (const p of ex.parts){
        const pt = p.life/p.ttl;
        if (pt>=1) continue;
        ctx.globalAlpha = 0.95*(1-pt);
        ctx.fillStyle="#fff";
        ctx.fillRect(p.x,p.y,2,2);
      }
      ctx.globalAlpha=1;
      ctx.lineWidth=1;
    }

    // end overlays
    if (state.screen === "end"){
      ctx.fillStyle="rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle="#fff";
      ctx.textAlign="center";
      ctx.font="28px sans-serif";

      if (state.endKind === "lose"){
        ctx.fillText("GAME OVER", W/2, H/2 - 44);
        ctx.font="16px sans-serif";
        ctx.fillText("やりなおす？", W/2, H/2 - 14);
      } else if (state.endKind === "secretWin"){
        ctx.fillText("CLEAR!", W/2, H/2 - 44);
        ctx.font="18px sans-serif";
        ctx.fillText("おめでとう！！！君は今年中幸せだ！！", W/2, H/2 - 10);
      } else {
        ctx.fillText("CLEAR!", W/2, H/2 - 44);
        ctx.font="16px sans-serif";
        ctx.fillText("もう一回", W/2, H/2 - 14);
      }

      ctx.textAlign="left";
    }

    // touch overlay
    if (touchMode && state.running){
      ctx.globalAlpha=0.16;
      ctx.strokeStyle="#fff";
      ctx.beginPath();
      ctx.moveTo(W/2,H*0.72); ctx.lineTo(W/2,H);
      ctx.moveTo(0,H*0.72); ctx.lineTo(W,H*0.72);
      ctx.stroke();

      ctx.globalAlpha=0.22;
      ctx.fillStyle="#fff";
      ctx.font="18px sans-serif";
      ctx.textAlign="center";
      ctx.fillText("◀︎", W*0.25, H*0.87);
      ctx.fillText("▶︎", W*0.75, H*0.87);
      ctx.textAlign="left";
      ctx.globalAlpha=1;
    }
  }

  // ===== Boot =====
  applyScreenAwareTuning();
  resetPlayer();

  // tutorial start buttons
  hideButtons();
  showPrimary("はじめる", startGame);

  state.screen = "tutorial";
  state.running = false;

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
